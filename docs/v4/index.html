<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Horde Calc</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.5.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link rel="icon" type="image/png" href="horde-logo-250.png"/>

    <style>

        <!-- scrollbars -->

        body { /* totaly strange, but if this is not here, the scrollbar doesnt work */
        }

        /* Scroll 6 */
        .sc6::-webkit-scrollbar {
            width: 8px;
            height: 8px;

        }
        .sc6::-webkit-scrollbar-track {
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0.4);
        }
        .sc6::-webkit-scrollbar-thumb {
            background-color: #aab74d;
            background-image:linear-gradient(to left top,#f5f97f 0,#17c139 95%,#17c139);
            border-radius: 10px;
        }
        <!-- scrollbars end -->


        .blockie {
            border: 1px solid black;
            border-radius: 5px;
        }

        #main-container {
            padding: 5px;
        }

        .form-container {
            padding: 1.5rem;
            margin-right: 0;
            margin-left: 0;
            border-width: 1px;
            border-top-left-radius: .25rem;
            border-top-right-radius: .25rem;
            margin: 1rem -.75rem 0;
            border: solid #dee2e6;
        }

        .standard-size-plot{
            width:95%; height: 500px;
        }

        body {
            background-color: #16191d;
            color: #f5f5f5;
        }

        .horde-default-background {
            background-color: #16191d;
        }

        .btn-horde:hover {
            background-color: #17C139;
            border-color: #17C139;
        }

        .horde-purple-background {
            background-color: #6C0EB6;
        }

        .horde-purple-border {
            border-color: #6C0EB6;
        }

        .horde-white-text {
            color: #dee2e6;
        }

        .btn-grad
        {
            background:-webkit-gradient(linear,right bottom,left top,from(#f5f97f),color-stop(65%,#17c139),to(#17c139));
            background:linear-gradient(to left top,#f5f97f 0,#17c139 65%,#17c139);
            color:#000;
            border:none
        }
        .btn-grad:hover{
            color:#e2e2e2
        }

        .nav-tabs {
            border-bottom: 1px solid #6C0EB6;
        }

        .nav-link {
            color: #dee2e6 !important;
            border-color: #6C0EB6 !important;
            cursor: pointer;
        }

        .nav-tabs .nav-link:hover {
            color: #dee2e6;
            background-color: #6C0EB6;
        }

        .tab-active {
            background:-webkit-gradient(linear,right bottom,left top,from(#f5f97f),color-stop(65%,#17c139),to(#17c139)) !important;
            background:linear-gradient(to left top,#f5f97f 0,#17c139 65%,#17c139) !important;
            color:#000 !important;
            border:none;
            cursor: pointer;
        }

        .tab-active:hover {
            color: #dee2e6 !important;
        }

        .template-cards-container {
            display: flex;
            flex-direction: row;
            overflow-x: auto;
            padding-bottom: 1rem;
        }

        .template-card {
            flex-shrink : 0;
            width: 13rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-width: 0;
            word-wrap: break-word;
            background-clip: border-box;
            border: 2px solid rgba(0,0,0,.125);
            border-radius: 1.5rem;
            border-color: #6C0EB6;
            margin-right: 1rem;
        }

        .template-card {
            padding: 0.3rem;
        }

        .template-card .card-header {
            font-size: 1.2em;
        }

        .template-card .card-header-small {
            font-size: 1.1em;
        }

        .template-card .card-header-smaller {
            font-size: 1em;
        }

        .template-card .template-card-body {
            padding-left: 2rem;
            padding-bottom: 0.5rem;
        }


        .template-card .template-card-body .card-row {
            width: 95%;
            display: block;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #6C0EB6;
            margin-bottom: 0.5rem;
            padding-left: 0.8rem;
        }
        .template-card .template-card-body .card-row .card-row-number{
            font-size: 1.2em;
        }

        .template-card .template-card-pencil {
            position: absolute;
            top: 3%;
            right: 2%;
            font-size: 14px;
            cursor: pointer;
            padding: 3px 8px 3px 8px;
            border-radius: 1rem;
            user-select: none;
        }

        .template-select-container .template-card-pencil {
            font-size: 14px;
            cursor: pointer;
            padding: 7px;
            border-radius: 1rem;
            user-select: none;
        }

        .template-card-pencil:hover {
            background-color: #6C0EB6;
        }

        .template-card .template-card-copy {
            position: absolute;
            top: 20%;
            right: 2%;
            font-size: 16px;
            cursor: pointer;
            padding: 2px 7px 2px 7px;
            border-radius: 1rem;
            user-select: none; /* Standard */
        }

        .template-card .template-card-copy:hover {
            background-color: #6C0EB6;
        }

        .template-card .template-card-trash {
            position: absolute;
            top: 37%;
            right: 2%;
            font-size: 14px;
            cursor: pointer;
            padding: 4px;
            border-radius: 1rem;
            user-select: none;
        }

        .template-card .template-card-trash:hover {
            background-color: #6C0EB6;
        }

        #ptem-outer-body {
            max-width: 35rem;
        }

        .ptem-datepicker {
            width: 10rem;
        }

        .ptem-plotcount {
            width: 5rem;
            text-align: right;
        }

        .ptem-nftcount {
            width: 5rem;
            text-align: right;
        }

        .ptem-plot-group {
            margin-bottom: 0.3rem;
        }

        .ptem-delete {
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            border-radius: 1rem;
            user-select: none;
        }

        .ptem-delete:hover {
            background-color: #6C0EB6;
        }

        .form-check-input:checked {
            background-color: #17C139;
            border-color:  #f5f97f;
        }

        .horde-radio-button {
            margin-top: 1em;
        }

        .graph-header {
            padding-left: 20px;
            display: inline
        }

        .post-graph-header-note {
            font-size: 0.6em
        }

        .pencil-img {
            background-image: url("pencil.png");
            width: 2px;
            height: 2px;
            display: inline-block;
            filter: invert(100%);
            background-size: contain;
            padding: 8px;
        }

        #calculator-tab-error{
            color: red;
        }

        .buying-prio-row {
            margin-top: 0.5rem;
        }

    </style>
</head>
<body class="horde-white-text sc6">
<div style="display: none" class="container" id="main-container">
    <div id="horde-header">
        <br>
        <img alt="logo" src="horde-logo-250.png"/>
        <br>
    </div>
    <div>
        Link to how-to
        <a target="_blank" class="horde-white-text" href="https://github.com/anonuser123abc/horde-calculator/blob/master/how-to.md">https://github.com/anonuser123abc/horde-calculator/blob/master/how-to.md</a>
    </div>
    <br>
    <div>
        <div>
            <ul class="nav nav-tabs">
                <li class="nav-item">
                    <span id="znft-tab-btn" onclick="openTab('znft-tab')" class="nav-link tab-active">zNFT Calculator</span>
                </li>
                <li class="nav-item">
                    <span id="calculator-tab-btn" onclick="openTab('calculator-tab')" class="nav-link" aria-current="page" href="#">Calculator</span>
                </li>
                <li class="nav-item">
                    <span id="templates-tab-btn" onclick="openTab('templates-tab')" class="nav-link">Templates</span>
                </li>
                <li class="nav-item">
                    <span id="simple-calculator-tab-btn" onclick="openTab('simple-calculator-tab')" class="nav-link">Simple calculator</span>
                </li>
            </ul>
        </div>
        <br>
        <div style="display: none" id="znft-tab">

            <div id="znft-tab-error-container" style="display: none"><h2 id="znft-tab-error"></h2></div>
            <div id="znft-tab-body">
                <h3>
                    zNFT Calculator
                </h3>

                <div>
                    <div class="form-container horde-purple-border">
                        <span id="znft-calc-generic-error" style="color: red; display:none"></span>
                        <div class="row">
                            <div class="col-5">
                                <label class="form-label" for="znft_calculator_user_rarity_score">Your Rarity Score:</label>
                                <br>
                                <input class="form-control" value="5" type="number" id="znft_calculator_user_rarity_score" style="width: 60%" step="1"/>
                                <br>
                                <label class="form-label" for="znft_calculator_invested">$$$ Invested:</label>
                                <br>
                                <input class="form-control" value="400" min="0" type="number" id="znft_calculator_invested" style="width: 60%" step="1"/>
                                <br>
                                <label class="form-label" for="znft_calculator_months">Months in future:</label>
                                <br>
                                <input class="form-control" value="24" type="number" id="znft_calculator_months" style="width: 60%"/>
                                <br>
                                <button onclick="runZnftCalculation()" class="btn btn-primary btn-grad">Calculate &nbsp:)</button> (scroll down)
                            </div>
                            <div class="col-5">
                                <label class="form-label" for="znft_calculator_system_rarity_score">System Rarity Score:</label>
                                <br>
                                <input class="form-control" value="50000" type="number" id="znft_calculator_system_rarity_score" style="width: 60%" step="1"/>
                                <br>
                                <label class="form-label" for="znft_calculator_minted_left">Minted left:</label>
                                <br>
                                <input class="form-control" value="6000" min="0" max="10000" type="number" id="znft_calculator_minted_left" style="width: 60%" step="1"/>
                                <br>
                                <label class="form-label" for="znft_calculator_bot_monthly_roi">Assumed monthly bot profits (usually 10-20%):</label>
                                <br>
                                <input class="form-control" value="0" min="0" type="number" id="znft_calculator_bot_monthly_roi" style="width: 60%" step="1"/>
                                <br>
                            </div>
                        </div>
                    </div>
                    <!-- add charts -->
                    <div style="display: none; color: red" id="znft-calculator-noroi-message">
                        <h4>You must input "Assumed monthly bot profits"</h4>
                    </div>
                    <div id="znft-calculation-results" style="display: none">
                        <br>
                        <div>
                            <h3>Initial Bot funds: <span id="znft_result_bot_initial_funds"></span></h3>
                        </div>
                        <div>
                            <h3>User RS share: <span id="znft_result_user_rs_share"></span></h3>
                        </div>
                        <br>
                        <br>
                        <h1 class="graph-header">User Share Monthly</h1> <span class="post-graph-header-note">(you can toggle the lines by clicking on the labels)</span>
                        <br>
                        <div class="standard-size-plot">
                            <canvas id="znftCalculatorUserProfits"></canvas>
                        </div>
                        <br>
                        <br>
                        <h1 class="graph-header">Monthly Profits</h1> <span class="post-graph-header-note">(you can toggle the lines by clicking on the labels)</span>
                        <br>
                        <div class="standard-size-plot">
                            <canvas id="znftCalculatorMonthlyProfits"></canvas>
                        </div>
                        <br>

                    </div>
                </div>
            </div>

        </div>
        <div style="display: none" id="calculator-tab">
            <div id="calculator-tab-error-container" style="display: none"><h2 id="calculator-tab-error"></h2></div>
            <div id="calculator-tab-body">
                <h3>
                    Calculator
                </h3>
                <div>
                    <div class="form-container horde-purple-border">
                        <span id="calc-no-template-error" style="color: red; display:none">No templates found, create one!</span>
                        <span id="calc-generic-error" style="color: red; display:none"></span>
                        <div class="row">
                            <div class="col-5">
                                <label class="form-label" >Select a template</label>
                                <br>
                                <div class="template-select-container input-group mb-3">
                                    <div class="input-group-prepend">
                                        <label class="input-group-text" for="calculator-template-select">Template</label>
                                    </div>
                                    <br/>
                                    <select style="font-size: 0.8em" id="calculator-template-select">
                                    </select>
                                    <span onclick="openSelectPTEM()" class=" template-card-pencil"><span class="pencil-img" style="padding: 10px;"></span></span>
                                </div>
                                <label class="form-label" for="calculator_num_of_claimable">Claimable tokens at the moment:</label>
                                <br>
                                <input class="form-control" value="0" type="number" id="calculator_num_of_claimable" style="width: 60%" step="0.001"/>
                                <br>
                                <label class="form-label" for="calculator_num_of_days_in_future">Duration in future:</label>
                                <br>
                                <input class="form-control" value="500" type="number" id="calculator_num_of_days_in_future" style="width: 60%"/>
                                <br>
                                <button onclick="runCalculation()" class="btn btn-primary btn-grad">Compound &nbsp:)</button> (scroll down)
                            </div>
                            <div class="col-4">

                                <label class="form-label" for="calculator_wallets_hardcap"># Wallets Hardcap (how many wallets you use)</label>
                                <br>
                                <input class="form-control" value="1" min="1" max="5" type="number" id="calculator_wallets_hardcap" style="width: 60%" step="1"/>
                                <br>
                                <label class="form-label" for="calculator_wallets_hardcap">$$$ Invested (optional)</label>
                                <br>
                                <input class="form-control" value="0" min="0" type="number" id="calculator_invested" style="width: 60%" step="1"/>
                                <br>
                                <label class="form-label" for="calculator_wallets_hardcap">$$$ Cashed Out Already (optional)</label>
                                <br>
                                <input class="form-control" value="0" min="0" type="number" id="calculator_cashed_out_already" style="width: 60%" step="1"/>
                                <br>
                            </div>

                            <div class="col-3" id="calculator-strategies-container">
                                <span>Choose a strategy:</span>
                                <div style="padding-left: 0.8em">
                                    <div class="form-check horde-radio-button">
                                        <input class="form-check-input" type="radio" name="calculator_strategy" id="strategy_full_compound" value="strategy_full_compound" checked>
                                        <label class="form-check-label" for="strategy_full_compound">
                                            Full Compound <span style="font-size: 0.6em">(compound until the hardcap is hit)</span>
                                        </label>
                                    </div>
                                    <div class="form-check horde-radio-button">
                                        <input class="form-check-input" type="radio" name="calculator_strategy" id="strategy_cashout_breakeven" value="strategy_cashout_breakeven">
                                        <label class="form-check-label" for="strategy_cashout_breakeven">
                                            Cashout Until Breakeven  <span style="font-size: 0.6em">(then compound)</span>
                                        </label>
                                    </div>
                                </div>
                                <span>Buying and priority:</span>
                                <div>
                                    <div class="buying-prio-row">
                                        <label><input id="calc-plots-checkbox" onchange="plotsCheckOnChange()" checked type="checkbox" value="plots" /> Plots </label>&nbsp; <select onchange="priorityChanged('plots')" id="plots-priority"><option selected value="1">1</option><option value="2">2</option><option value="3">3</option></select>
                                    </div>
                                    <div class="buying-prio-row">
                                        <label><input id="calc-stones-checkbox" onchange="stonesCheckOnChange()" type="checkbox" value="stones" /> Stones </label>&nbsp; <select onchange="priorityChanged('stones')" id="stones-priority" style="display: none" ><option value="1">1</option><option selected value="2">2</option><option value="3">3</option></select>
                                    </div>
                                    <div class="buying-prio-row">
                                        <label><input id="calc-runes-checkbox" onchange="runesCheckOnChange()" type="checkbox" value="runes" /> Runes </label>&nbsp; <select onchange="priorityChanged('runes')" id="runes-priority" style="display: none"><option value="1">1</option><option value="2">2</option><option selected value="3">3</option></select>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div style="display: none" id="calculator-notemp-message">
                        There are no templates in the system, create some in the "Templates" tab!
                    </div>


                    <h1 class="graph-header">Plot Graph</h1> <span class="post-graph-header-note">(you can toggle the lines by clicking on the labels)</span>
                    <br>
                    <div class="standard-size-plot">
                        <canvas id="calculatorActivePlotsGraph"></canvas>
                    </div>
                    <br>
                    <h1 class="graph-header">Horde Daily Income</h1>
                    <br>
                    <div class="standard-size-plot">
                        <canvas id="calculatorHordeIncomeGraph"></canvas>
                    </div>
                    <br>
                    <br>
                    <h1 class="graph-header">Cashout Graph</h1> <span class="post-graph-header-note">(you can toggle the lines by clicking on the labels)</span>
                    <br>
                    <div class="standard-size-plot">
                        <canvas id="calculatorCashoutGraph"></canvas>
                    </div>
                    <br>
                    <h1 class="graph-header">Tokenomics Graph</h1> <span class="post-graph-header-note">(you can toggle the lines by clicking on the labels)</span>
                    <br>
                    <div class="standard-size-plot">
                        <canvas id="calculatorTokenomicsGraph"></canvas>
                    </div>
                    <br>
                    <br>
                    <h1 class="graph-header">Tokenomics in $$$ Graph</h1> <span class="post-graph-header-note">(you can toggle the lines by clicking on the labels)</span>
                    <br>
                    <div class="standard-size-plot">
                        <canvas id="calculatorTokenomicsDollarsGraph"></canvas>
                    </div>
                    <br>
                </div>
            </div>
        </div>
        <div style="display: none" id="templates-tab">
            <div>
                <h3 style="display: inline-block">
                    Plot Templates
                </h3>
                <button onclick="openCreatePTEM()" style="margin-left: 0.7rem; margin-bottom: .5rem;" class="btn btn-primary btn-grad">+ New</button>
            </div>
            <div class="sc6 template-cards-container" id="templates-tab-container">
                <div style="display: none"  class="template-card">  <!-- just a template for testing styles, change display style to play with -->
                    <div class="card-header">
                        Wishful Thinking
                    </div>
                    <div class="card-body">
                        <span class="card-row"><span class="card-row-number">8</span> plots</span>
                        <span class="card-row"><span class="card-row-number">3</span> NFTs</span>
                    </div>
                </div>
            </div>
        </div>
        <div style="display: none" id="simple-calculator-tab" >
            <h3>
                Simple calculator - it supposes plots were created today
            </h3>
            <div class="form-container horde-purple-border">
                <form onsubmit="return false" >
                    <label class="form-label" for="scalc_num_of_plots">How many plots:</label><br>
                    <input onchange="testch()" class="form-control" value="1" type="number" id="scalc_num_of_plots" style="width: 20%"/>
                    <br>
                    <label class="form-label" for="scalc_num_of_claimable">How many claimable tokens you have at the moment:</label>
                    <br>
                    <input class="form-control" value="0" type="number" id="scalc_num_of_claimable" style="width: 20%" step="0.001"/>
                    <br>
                    <label class="form-label" for="scalc_num_of_days_in_future">Duration in future:</label>
                    <br>
                    <input class="form-control" value="500" type="number" id="scalc_num_of_days_in_future" style="width: 20%"/>
                    <br>
                    <button onclick="runSimpleCalculation()" class="btn btn-primary btn-grad">Compound &nbsp:)</button> (scroll down)
                </form>
            </div>
            <br>
            <div style="padding: 5px; display: none" id="results">
                <h1 style="padding-left: 20px">Plot Graph</h1>
                <br>
                <div class="standard-size-plot">
                    <canvas id="scalcActivePlotsGraph"></canvas>
                </div>
                <br>
                <br>
                <div id="monthly-results">
                    <h3>Monthly printouts</h3>
                    <div id="monthly-results-raw"></div>
                </div>
            </div>
        </div>
    </div>
</div>



<!-- MODALS -->

<!-- Plot Template Editor Modal -->
<div class="sc6 horde-modal modal fade" id="plot-template-editor-modal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div id="ptem-outer-body" class="modal-dialog">
        <div class="horde-default-background modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="ptem-title">Modal title</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div id="ptem-body" class="modal-body">
                Name <input id="ptem-name" style="font-size: 14px" maxlength="18">
                <br>
                <br>
                <div>
                    Plot groups
                    <br>
                    <div style="border-bottom: 1px solid white;">
                        <span style="font-size: 1.2rem;">#. &nbsp&nbsp&nbsp&nbsp</span> <span style="width: 5rem; display: inline-block; text-align: center;">plot count</span> &nbsp <span style="width: 10rem; display: inline-block; text-align: center;">creation date</span> &nbsp <span style="width: 10rem; display: inline-block; text-align: center;">decay date</span>
                    </div>
                    <br>
                    <div>
                        <!-- Wow such empty -->
                        <div id="ptem-plot-groups">
                        </div>
                        <br>
                        <button onclick="addEmptyPlotGroupToPtem()" style="margin-left: 0.7rem; margin-bottom: .5rem;" class="btn btn-primary btn-grad">+ Another Plot Group</button>
                    </div>
                </div>
                <br>
                <div>
                    Soul Stones
                    <br>
                    <div style="border-bottom: 1px solid white;">
                        <span style="font-size: 1.2rem;">#. &nbsp&nbsp&nbsp</span> &nbsp <span style="width: 10rem; display: inline-block; text-align: center;">creation date</span> &nbsp <span style="width: 10rem; display: inline-block; text-align: center;">decay date</span>
                    </div>
                    <br>
                    <div style="border-bottom: 1px solid white;">
                        <!-- Wow such empty -->
                        <div id="ptem-stones">
                        </div>
                        <button onclick="addEmptyStoneToPtem()" style="margin-left: 0.7rem; margin-bottom: .5rem;" class="btn btn-primary btn-grad">+ Add Souls Stone</button>
                    </div>
                </div>
                <br>
                <div>
                    Soul Runes
                    <br>
                    <div style="border-bottom: 1px solid white;">
                        <span style="font-size: 1.2rem;">#. &nbsp&nbsp&nbsp</span> &nbsp <span style="width: 10rem; display: inline-block; text-align: center;">creation date</span> &nbsp <span style="width: 10rem; display: inline-block; text-align: center;">decay date</span>
                    </div>
                    <br>
                    <div style="border-bottom: 1px solid white;">
                        <!-- Wow such empty -->
                        <div id="ptem-runes">
                        </div>
                        <button onclick="addEmptyRuneToPtem()" style="margin-left: 0.7rem; margin-bottom: .5rem;" class="btn btn-primary btn-grad">+ Add Souls Rune</button>
                    </div>
                </div>
                <div style="border-bottom: 1px solid white; margin-top: 1rem;margin-bottom: 1rem; padding-bottom: 1rem">
                    NFTs
                    <div>
                        <label style="width: 5rem;" for="ptem-nft5perc">NFT 5%</label><input min="0" onchange="ptemNft5Changed()" id="ptem-nft5perc" class="ptem-nftcount" type="number" value="0">
                        <br>
                        <label style="width: 5rem;" for="ptem-nft10perc">NFT 10%</label><input min="0" onchange="ptemNft10Changed()" id="ptem-nft10perc" class="ptem-nftcount" type="number" value="0">
                        <br>
                        <label style="width: 5rem;" for="ptem-nft15perc">NFT 15%</label><input min="0" onchange="ptemNft15Changed()" id="ptem-nft15perc" class="ptem-nftcount" type="number" value="0">
                        <br>
                    </div>
                </div>
                Total plots: <span id="ptem-total-plots">1</span>
                <br>
                Total souls stones: <span id="ptem-total-stones">0</span>
                <br>
                Total souls runes: <span id="ptem-total-runes">0</span>
                <br>
                Total NFTs: <span id="ptem-total-nfts">0</span>
            </div>
            <span id="ptem-error" style="color: red; display:none"></span>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button onclick="onPtemSaveClick()" id="ptem-save-btn" type="button" class="btn btn-primary btn-grad"></button>
            </div>
        </div>
    </div>
</div>



</body>
</html>

<script>
    const LIVE_WALLET_TEMPLATE_NAME = 'Live Wallet'
    const LIVE_WALLET_TEMPLATE_NAME_EDITED = 'Live Wallet Edited'
    const BE_CREATIVE_NAME = '-- be creative --';

    const STRATEGY_FULL_COMPOUND = 'strategy_full_compound'
    const STRATEGY_CASHOUT_BREAKEVEN = 'strategy_cashout_breakeven'

    const HORDE_CURRENT_MIDDLE_PRICE = 105.5;

    let FORBIDDEN_NAMES = {};
    FORBIDDEN_NAMES[LIVE_WALLET_TEMPLATE_NAME] = 1;
    FORBIDDEN_NAMES[LIVE_WALLET_TEMPLATE_NAME_EDITED] = 1;
    FORBIDDEN_NAMES[BE_CREATIVE_NAME] = 1;

    const PLOT_DECAY = 300;
    const STONE_DECAY = 250;
    const RUNE_DECAY = 200;

    const ZNFT_MAX_COUNT = 10000;
    const ZNFT_AVERAGE_MONTHLY_BOT_ROI = 0.15; //15%
    const ZNFT_BOT_SHARE_OF_FUNDS = 0.4; //40%

    const ZNFT_BOT_PROFIT_HORDE_POOL_SHARE = 0.05; //5%
    const ZNFT_BOT_PROFIT_LM_SHARE = 0.2; //20%
    const ZNFT_BOT_PROFIT_COMPOUND_SHARE = 0.25; //25%
    const ZNFT_BOT_PROFIT_HOLDERS_SHARE = 0.5; //50%
    //5+20+25+50 = 100%


    const PTEM_MODE_CREATE = 'create';
    const PTEM_MODE_EDIT = 'edit';
    const PTEM_MODE_EDIT_LIVE_WALLET = 'edit_live_wallet';


    let GLOBAL_DATA = readLocalStorage();

    let currentTab = '';
    let templateFromInput = null;
    let plotTemplateEditorModal = new bootstrap.Modal(document.getElementById('plot-template-editor-modal'))
    let ptemGroupsDiv = document.getElementById('ptem-plot-groups');
    let ptemStonesDiv = document.getElementById('ptem-stones');
    let ptemRunesDiv = document.getElementById('ptem-runes');
    let ptemName = document.getElementById('ptem-name')
    let ptemTotalPlots = document.getElementById('ptem-total-plots')
    let ptemTotalStones = document.getElementById('ptem-total-stones')
    let ptemTotalRunes = document.getElementById('ptem-total-runes')
    let ptemTotalNfts = document.getElementById('ptem-total-nfts')
    let ptemSaveButton = document.getElementById('ptem-save-btn')
    let ptemError = document.getElementById('ptem-error')
    let templatesTabContainer = document.getElementById('templates-tab-container')

    let calculatorTemplatesSelect = document.getElementById('calculator-template-select')
    let ptemMode = null;

    let currentPtemTemplate = {}
    //openCreatePTEM();

    function showNoTemplateError() {
        document.getElementById('calc-no-template-error').style.display = 'block'
    }

    function hideNoTemplateError() {
        document.getElementById('calc-no-template-error').style.display = 'none'
    }

    function showCalculatorError(msg) {
        document.getElementById('calc-generic-error').innerText = msg
        document.getElementById('calc-generic-error').style.display = 'block'
    }

    function hideCalculatorError() {
        document.getElementById('calc-generic-error').innerText = ''
        document.getElementById('calc-no-template-error').style.display = 'none'
    }

    function userHasTemplates() {
        return !(templateFromInput === null && isEmpty(GLOBAL_DATA.templates));
    }

    function getSelectedStrategy() {
        return document.querySelector('input[name="calculator_strategy"]:checked').value;
    }

    function populateCalculatorTemplatesSelect(keepSameSelectedIfFound) {
        let selectedTemplateName = calculatorTemplatesSelect.value;
        console.log(selectedTemplateName)
        calculatorTemplatesSelect.innerHTML = '';
        if(templateFromInput !== null) {
            calculatorTemplatesSelect.insertAdjacentHTML(
                'beforeend',
                generateTemplateOption(templateFromInput, selectedTemplateName === templateFromInput.name)
            );
        }
        for(let name in GLOBAL_DATA.templates) {
            calculatorTemplatesSelect.insertAdjacentHTML(
                'beforeend',
                generateTemplateOption(GLOBAL_DATA.templates[name], selectedTemplateName === name)
            );
        }
    }

    function generateTemplateOption(template, selected) {
        let selectedText = selected ? 'selected' : '';
        return `
            <option value="${template.name}" ${selectedText} id="${template.name}">${template.name} (${template.plotCount}p ${template.stones.length}s ${template.runes.length}r | ${template.nftCount} NFTs)</option>
        `;
    }

    function setInitialInputs(inputsData) {
        document.getElementById("calculator_num_of_days_in_future").value = inputsData.duration_in_future.toString()
        document.getElementById("calculator_wallets_hardcap").value = inputsData.wallets_hardcap.toString()
        document.getElementById("calculator_invested").value = inputsData.invested.toString()
        document.getElementById("calculator_cashed_out_already").value = inputsData.cashed_out_already.toString()
        document.getElementById(inputsData.chosen_strategy).checked = true;
    }

    function setInitialZnftInputs(inputsData) {
        document.getElementById("znft_calculator_user_rarity_score").value = inputsData.znft_calculator_user_rarity_score.toString()
        document.getElementById("znft_calculator_invested").value = inputsData.znft_calculator_invested.toString()
        document.getElementById("znft_calculator_months").value = inputsData.znft_calculator_months.toString()
        document.getElementById("znft_calculator_system_rarity_score").value = inputsData.znft_calculator_system_rarity_score.toString()
        document.getElementById("znft_calculator_minted_left").value = inputsData.znft_calculator_minted_left.toString()
    }

    function readLocalStorage() {
        let data = localStorage.getItem('horde-calc-global-data');
        let defaultInputs = {
            'duration_in_future': 500,
            'wallets_hardcap': 1,
            'invested': 0,
            'cashed_out_already': 0,
            'chosen_strategy': STRATEGY_FULL_COMPOUND,
        };

        let defaultZnftInputs = {
            'znft_calculator_user_rarity_score': 13,
            'znft_calculator_invested': 400,
            'znft_calculator_months': 24,
            'znft_calculator_system_rarity_score': 50000,
            'znft_calculator_minted_left': 6000,
        };

        if(data === null) {
            return {
                'templates': {
                    //keyed by name
                },
                'inputs': defaultInputs,
                'znft_inputs': defaultZnftInputs
            };
        } else {
            let dataAsJson = JSON.parse(data);

            //convert all date strings to date objects
            for(let name in dataAsJson.templates) {
                let template = dataAsJson.templates[name]
                template.plotGroups.forEach((x, i) =>
                    {
                        template.plotGroups[i].createdAt = new Date(template.plotGroups[i].createdAt)
                        template.plotGroups[i].expiresAt = new Date(template.plotGroups[i].expiresAt)
                    }
                )

                if('stones' in template) {
                    template.stones.forEach((x, i) =>
                        {
                            template.stones[i].createdAt = new Date(template.stones[i].createdAt)
                            template.stones[i].expiresAt = new Date(template.stones[i].expiresAt)
                        }
                    )
                } else {
                    template.stones = [];
                }

                if('runes' in template) {
                    template.runes.forEach((x, i) =>
                        {
                            template.runes[i].createdAt = new Date(template.runes[i].createdAt)
                            template.runes[i].expiresAt = new Date(template.runes[i].expiresAt)
                        }
                    )
                } else {
                    template.runes = [];
                }
            }

            //TODO: do a foreach and fill missing fields if some are missing
            if(!('inputs' in dataAsJson)) {
                dataAsJson['inputs'] = defaultInputs
            }

            if(!('znft_inputs' in dataAsJson)) {
                dataAsJson['znft_inputs'] = defaultZnftInputs
            }

            return dataAsJson;
        }
    }

    function writeToLocalStorage(data) {
        let dataClone = clone(data)

        //convert all dates to strings
        for(let name in dataClone.templates) {
            let template = dataClone.templates[name]
            template.plotGroups.forEach((x, i) =>
                {
                    template.plotGroups[i].createdAt = dateOnlyString(template.plotGroups[i].createdAt)
                    template.plotGroups[i].expiresAt = dateOnlyString(template.plotGroups[i].expiresAt)
                }
            )
            template.stones.forEach((x, i) =>
                {
                    template.stones[i].createdAt = dateOnlyString(template.stones[i].createdAt)
                    template.stones[i].expiresAt = dateOnlyString(template.stones[i].expiresAt)
                }
            )
            template.runes.forEach((x, i) =>
                {
                    template.runes[i].createdAt = dateOnlyString(template.runes[i].createdAt)
                    template.runes[i].expiresAt = dateOnlyString(template.runes[i].expiresAt)
                }
            )
        }

        localStorage.setItem('horde-calc-global-data', JSON.stringify(dataClone))
    }

    function openCreatePTEM() {
        document.getElementById('ptem-title').innerText = "Create new template";
        currentPtemTemplate = createPlotTemplate(
            [
                createPlotGroupFromCreation(new Date(), 5),
                createPlotGroupFromCreation(copyAndAddDays(new Date(), 5), 1),
                createPlotGroupFromCreation(copyAndAddDays(new Date(), 15), 1),
            ],
            [],
            [],
            createEmptyNftGroup(),
            BE_CREATIVE_NAME
        )
        preparePtem(currentPtemTemplate)
        ptemSaveButton.innerText = "Create Template"
        ptemMode = PTEM_MODE_CREATE;
        ptemName.disabled = false
        plotTemplateEditorModal.show()
    }

    function openWalletPTEM() {
        document.getElementById('ptem-title').innerText = "Edit live-wallet template (not permanent)";
        currentPtemTemplate = clone(templateFromInput)
        populatePtemMissingData(currentPtemTemplate);
        preparePtem(currentPtemTemplate)
        ptemSaveButton.innerText = "Update Live Template (temporarily)"
        ptemMode = PTEM_MODE_EDIT_LIVE_WALLET;
        ptemName.disabled = true
        plotTemplateEditorModal.show()
    }

    function openEditPTEM(template) {
        document.getElementById('ptem-title').innerText = "Edit '" + template.name + "' template";
        currentPtemTemplate = clone(template)
        populatePtemMissingData(currentPtemTemplate);
        preparePtem(currentPtemTemplate)
        ptemSaveButton.innerText = "Update"
        ptemMode = PTEM_MODE_EDIT;
        ptemName.disabled = false
        plotTemplateEditorModal.show()
    }

    function populatePtemMissingData(ptem) {
        if(!("stones" in ptem)) {
            ptem.stones = [];
        }
        if(!("runes" in ptem)) {
            ptem.runes = [];
        }
    }

    function openSelectPTEM() {
        let templateName = calculatorTemplatesSelect.value;
        if(!isEmpty(templateName)) {
            openPTEM(templateName)
        }
    }

    function openPTEM(name) {
        if(name === LIVE_WALLET_TEMPLATE_NAME || name === LIVE_WALLET_TEMPLATE_NAME_EDITED) {
            openWalletPTEM();
        } else {
            openEditPTEM(GLOBAL_DATA['templates'][name]);
        }
    }

    function deleteTemplate(name) {
        if(name in GLOBAL_DATA.templates) {
            delete GLOBAL_DATA.templates[name]
            syncAllTemplates()
        }
    }

    function copyTemplate(name) {

        let copiedTemplate = null
        if (name in GLOBAL_DATA.templates) {
            copiedTemplate = clone(GLOBAL_DATA.templates[name])
        } else if (name === LIVE_WALLET_TEMPLATE_NAME || name === LIVE_WALLET_TEMPLATE_NAME) {
            copiedTemplate = clone(templateFromInput)
        }

        if(copiedTemplate !== null) {
            let proposedName = '(copy) ' + name
            let i = 1;
            while (proposedName in GLOBAL_DATA.templates) {
                proposedName = '(copy ' + i + ') ' + name;
                if(i > 100) {
                    alert('Too much copied templates...')
                    return;
                }
                i++;
            }

            copiedTemplate.name = proposedName;
            GLOBAL_DATA.templates[proposedName] = copiedTemplate
            syncAllTemplates()
        }
    }

    function preparePtem(template) {
        ptemError.innerText = '';
        ptemError.style.display = 'none'
        ptemGroupsDiv.innerHTML = ''
        ptemStonesDiv.innerHTML = ''
        ptemRunesDiv.innerHTML = ''
        ptemName.value = template.name;
        ptemTotalPlots.innerText = template.plotCount;
        ptemTotalStones.innerText = template.stones.length + '';
        ptemTotalRunes.innerText = template.runes.length + '';
        ptemTotalNfts.innerText = template.nftCount;

        document.getElementById('ptem-nft5perc').value = template.nftGroup.nft5perc;
        document.getElementById('ptem-nft10perc').value = template.nftGroup.nft10perc;
        document.getElementById('ptem-nft15perc').value = template.nftGroup.nft15perc;

        template.plotGroups.forEach(
            (item, i) => {
                addPlotGroupToPtem(i, item)
            }
        )

        template.stones.forEach(
            (item, i) => {
                addStoneToPtem(i, item)
            }
        )
        template.runes.forEach(
            (item, i) => {
                addRuneToPtem(i, item)
            }
        )
    }

    function onPtemSaveClick() {
        if(
            currentPtemTemplate.plotGroups.length === 0
            && currentPtemTemplate.stones.length === 0
            && currentPtemTemplate.runes.length === 0
        ) {
            ptemError.innerText = 'Cant save a template that has no plots/stones/runes! Add at least one of something!'
            ptemError.style.display = 'block'
            return;
        }

        if(ptemMode === PTEM_MODE_CREATE || ptemMode === PTEM_MODE_EDIT) {

            if(ptemName.value in FORBIDDEN_NAMES) {
                ptemError.innerText = 'That name is not allowed! Try a different one'
                ptemError.style.display = 'block'
                return;
            }

            if (
                (ptemMode === PTEM_MODE_CREATE && ptemName.value in GLOBAL_DATA.templates) //if new one is being created and the name is already taken
                ||
                (ptemMode === PTEM_MODE_EDIT && ptemName.value !== currentPtemTemplate.name && ptemName.value in GLOBAL_DATA.templates) //OR its edit, and the name is changed, and its changed to an existing one
            ) {
                ptemError.innerText = 'That name is already taken! Try a different one'
                ptemError.style.display = 'block'
                return;
            }

            //if its an edit and the name is changed, first remove the old key
            if(ptemMode === PTEM_MODE_EDIT && ptemName.value !== currentPtemTemplate.name) {
                delete GLOBAL_DATA.templates[currentPtemTemplate.name]
                currentPtemTemplate.name = ptemName.value;
            }

            currentPtemTemplate.name = ptemName.value;
            GLOBAL_DATA.templates[currentPtemTemplate.name] = clone(currentPtemTemplate);
            syncAllTemplates();

        } else if(ptemMode === PTEM_MODE_EDIT_LIVE_WALLET) {
            currentPtemTemplate.name = LIVE_WALLET_TEMPLATE_NAME_EDITED
            templateFromInput = clone(currentPtemTemplate)
            syncAllTemplates();
        }

        plotTemplateEditorModal.hide()
        currentPtemTemplate = null;
    }

    function syncAllTemplates() {
        writeToLocalStorage(GLOBAL_DATA)
        renderTemplates()
        populateCalculatorTemplatesSelect(true)
        if(userHasTemplates()) {
            hideNoTemplateError()
        } else {
            showNoTemplateError()

        }
    }

    function renderTemplates() {
        templatesTabContainer.innerHTML = '';
        if(templateFromInput !== null) {
            //plotTemplate, isLiveTemplate, isLiveTemplateEdited, generateEditPencil, generateDeleteButton
            templatesTabContainer.insertAdjacentHTML(
                'beforeend',
                generateTemplateUICard(templateFromInput, true, templateFromInput.name === LIVE_WALLET_TEMPLATE_NAME_EDITED, true, false, true)
            )
        }

        for(let templateName in GLOBAL_DATA.templates) {
            let template = GLOBAL_DATA.templates[templateName]
            templatesTabContainer.insertAdjacentHTML(
                'beforeend',
                generateTemplateUICard(template, false, false, true, true, true)
            )
        }
    }

    function addEmptyPlotGroupToPtem() {
        let date = copyAndAddDays(findNewestCreateDateInPlotTemplate(currentPtemTemplate), 1)
        let plotCount = 1;
        let newPlotGroup = createPlotGroupFromCreation(date, plotCount)
        addPlotGroupToPtem(currentPtemTemplate.plotGroups.length, newPlotGroup)
        currentPtemTemplate.plotGroups.push(newPlotGroup)
        currentPtemTemplate.plotCount = countPlots(currentPtemTemplate.plotGroups)

        ptemTotalPlots.innerText = currentPtemTemplate.plotCount.toString();
        ptemTotalNfts.innerText = currentPtemTemplate.nftCount.toString();
    }

    function addEmptyStoneToPtem() {
        if(currentPtemTemplate.stones.length >= 2) {
            alert("You can only have 2 Souls Stones!");
            return;
        }
        let date = copyAndAddDays(findNewestCreateDateInPlotTemplate(currentPtemTemplate), 1)
        let newStone = createStoneFromCreation(date)
        addStoneToPtem(currentPtemTemplate.stones.length, newStone)

        currentPtemTemplate.stones.push(newStone)
        currentPtemTemplate.plotCount = countPlots(currentPtemTemplate.plotGroups)
        ptemTotalStones.innerText = currentPtemTemplate.stones.length.toString();
    }

    function addEmptyRuneToPtem() {
        if(currentPtemTemplate.runes.length >= 10) {
            alert("You can only have 10 Souls Runes!");
            return;
        }
        let date = copyAndAddDays(findNewestCreateDateInPlotTemplate(currentPtemTemplate), 1)
        let newRune = createRuneFromCreation(date)
        addRuneToPtem(currentPtemTemplate.runes.length, newRune)

        currentPtemTemplate.runes.push(newRune)
        currentPtemTemplate.plotCount = countPlots(currentPtemTemplate.plotGroups)
        ptemTotalRunes.innerText = currentPtemTemplate.runes.length.toString();
    }

    function addPlotGroupToPtem(num, plotGroup) {
        ptemGroupsDiv.insertAdjacentHTML('beforeend', generatePlotGroupEditUI(num, plotGroup.count, dateOnlyString(plotGroup.createdAt), dateOnlyString(plotGroup.expiresAt)))
    }

    function addStoneToPtem(num, stone) {
        ptemStonesDiv.insertAdjacentHTML('beforeend', generateStoneEditUI(num, dateOnlyString(stone.createdAt), dateOnlyString(stone.expiresAt)))
    }

    function addRuneToPtem(num, rune) {
        ptemRunesDiv.insertAdjacentHTML('beforeend', generateRuneEditUI(num, dateOnlyString(rune.createdAt), dateOnlyString(rune.expiresAt)))
    }

    function findNewestCreateDateInPlotTemplate(template) {
        let newestDate = new Date()
        template.plotGroups.forEach(
            (item, i) => {
                if(item.createdAt > newestDate) {
                    newestDate = item.createdAt
                }
            }
        )

        return newestDate
    }

    function openTab(tabId) {
        if(tabId === currentTab) {
            return;
        }

        if(tabId === 'calculator-tab') {
            //check if there is any template, if not, say to them to create one!
            if(userHasTemplates()) {
                console.log("Has templates")
                document.getElementById('calculator-tab-error-container').style.display = 'none'
                document.getElementById('calculator-tab-body').style.display = 'block'
            } else {
                console.log("Has no templates")
                document.getElementById('calculator-tab-error').innerHTML = 'You have to create templates to be able to calculate! Go to templates tab'
                document.getElementById('calculator-tab-error-container').style.display = 'block'
                document.getElementById('calculator-tab-body').style.display = 'none'
            }
        }

        document.getElementById(tabId).style.display = 'block';
        document.getElementById(tabId + "-btn").classList.add('tab-active');

        let currentTabHtml = document.getElementById(currentTab);
        if(currentTabHtml !== null) {
            currentTabHtml.style.display = 'none'
            document.getElementById(currentTab + "-btn").classList.remove('tab-active');
        }

        currentTab = tabId;
    }

    function ptemPlotCountChanged(inputElement) {
        let plotGroupIndex = parseInt(inputElement.parentNode.dataset.pgroupid);
        currentPtemTemplate.plotGroups[plotGroupIndex].count = parseInt(inputElement.value)
        currentPtemTemplate.plotCount = countPlots(currentPtemTemplate.plotGroups)

        ptemTotalPlots.innerText = currentPtemTemplate.plotCount.toString();
        ptemTotalNfts.innerText = currentPtemTemplate.nftCount.toString();
    }

    function ptemPlotCreatedAtChanged(inputElement) {
        let plotGroupIndex = parseInt(inputElement.parentNode.dataset.pgroupid);

        let newCreatedAtDate = new Date(inputElement.value);
        let newDecayDate = copyAndAddDays(newCreatedAtDate, PLOT_DECAY);
        let decayAtElement = inputElement.parentNode.querySelectorAll('.plot-decay-at')[0];
        decayAtElement.value = dateOnlyString(newDecayDate);

        currentPtemTemplate.plotGroups[plotGroupIndex].createdAt = newCreatedAtDate;
        currentPtemTemplate.plotGroups[plotGroupIndex].expiresAt = newDecayDate;
    }

    function ptemPlotExpiresAtChanged(inputElement) {
        let plotGroupIndex = parseInt(inputElement.parentNode.dataset.pgroupid);

        let newDecayDate = new Date(inputElement.value);
        let newCreatedAtDate = copyAndAddDays(newDecayDate, -PLOT_DECAY);
        let createdAtElement = inputElement.parentNode.querySelectorAll('.plot-created-at')[0];
        createdAtElement.value = dateOnlyString(newCreatedAtDate);

        currentPtemTemplate.plotGroups[plotGroupIndex].createdAt = newCreatedAtDate;
        currentPtemTemplate.plotGroups[plotGroupIndex].expiresAt = newDecayDate;
    }
    function ptemStoneCreatedAtChanged(inputElement) {
        let stoneGroupIndex = parseInt(inputElement.parentNode.dataset.sstoneid);

        let newCreatedAtDate = new Date(inputElement.value);
        let newDecayDate = copyAndAddDays(newCreatedAtDate, STONE_DECAY);
        let decayAtElement = inputElement.parentNode.querySelectorAll('.stone-decay-at')[0];
        decayAtElement.value = dateOnlyString(newDecayDate);

        currentPtemTemplate.stones[stoneGroupIndex].createdAt = newCreatedAtDate;
        currentPtemTemplate.stones[stoneGroupIndex].expiresAt = newDecayDate;
    }

    function ptemStoneExpiresAtChanged(inputElement) {
        let stoneGroupIndex = parseInt(inputElement.parentNode.dataset.sstoneid);

        let newDecayDate = new Date(inputElement.value);
        let newCreatedAtDate = copyAndAddDays(newDecayDate, -STONE_DECAY);
        let createdAtElement = inputElement.parentNode.querySelectorAll('.stone-created-at')[0];
        createdAtElement.value = dateOnlyString(newCreatedAtDate);

        currentPtemTemplate.stones[stoneGroupIndex].createdAt = newCreatedAtDate;
        currentPtemTemplate.stones[stoneGroupIndex].expiresAt = newDecayDate;
    }

    function ptemRuneCreatedAtChanged(inputElement) {
        let runeGroupIndex = parseInt(inputElement.parentNode.dataset.sruneid);

        let newCreatedAtDate = new Date(inputElement.value);
        let newDecayDate = copyAndAddDays(newCreatedAtDate, RUNE_DECAY);
        let decayAtElement = inputElement.parentNode.querySelectorAll('.rune-decay-at')[0];
        decayAtElement.value = dateOnlyString(newDecayDate);

        currentPtemTemplate.runes[runeGroupIndex].createdAt = newCreatedAtDate;
        currentPtemTemplate.runes[runeGroupIndex].expiresAt = newDecayDate;
    }

    function ptemRuneExpiresAtChanged(inputElement) {
        let runeGroupIndex = parseInt(inputElement.parentNode.dataset.sruneid);

        let newDecayDate = new Date(inputElement.value);
        let newCreatedAtDate = copyAndAddDays(newDecayDate, -RUNE_DECAY);
        let createdAtElement = inputElement.parentNode.querySelectorAll('.rune-created-at')[0];
        createdAtElement.value = dateOnlyString(newCreatedAtDate);

        currentPtemTemplate.runes[runeGroupIndex].createdAt = newCreatedAtDate;
        currentPtemTemplate.runes[runeGroupIndex].expiresAt = newDecayDate;
    }

    function ptemDeletePlotGroup(inputElement) {
        let plotGroupIndex = parseInt(inputElement.parentNode.dataset.pgroupid);

        currentPtemTemplate.plotGroups.splice(plotGroupIndex, 1) //remove from data
        currentPtemTemplate.plotCount = countPlots(currentPtemTemplate.plotGroups)
        ptemTotalPlots.innerText = currentPtemTemplate.plotCount.toString();
        inputElement.parentNode.remove() //remove from UI

        //since the index is removed, array elements index have been reduced by one to fill the gap, so we start from the index itself until the end
        for (let i = plotGroupIndex; i < currentPtemTemplate.plotGroups.length; i++) {
            let oldId = i + 1;
            let newId = i;
            let elem = document.getElementById('pgroup-' + oldId);
            let textElem = document.getElementById('pgroup-number-' + oldId);
            elem.id = 'pgroup-' + newId.toString();
            elem.dataset.pgroupid = newId.toString();
            textElem.id = 'pgroup-number-' + newId.toString();
            textElem.innerHTML = generatePlotGroupNumberText(newId + 1);
        }
    }

    function ptemDeleteStone(inputElement) {
        let index = parseInt(inputElement.parentNode.dataset.sstoneid);

        currentPtemTemplate.stones.splice(index, 1) //remove from data
        ptemTotalStones.innerText = currentPtemTemplate.stones.length.toString();
        inputElement.parentNode.remove() //remove from UI

        //since the index is removed, array elements index have been reduced by one to fill the gap, so we start from the index itself until the end
        for (let i = index; i < currentPtemTemplate.stones.length; i++) {
            let oldId = i + 1;
            let newId = i;
            let elem = document.getElementById('sstone-' + oldId);
            let textElem = document.getElementById('sstone-number-' + oldId);
            elem.id = 'sstone-' + newId.toString();
            elem.dataset.sstoneid = newId.toString();
            textElem.id = 'sstone-number-' + newId.toString();
            textElem.innerHTML = generatePlotGroupNumberText(newId + 1);
        }
    }

    function ptemDeleteRune(inputElement) {
        let index = parseInt(inputElement.parentNode.dataset.sruneid);

        currentPtemTemplate.runes.splice(index, 1) //remove from data
        ptemTotalRunes.innerText = currentPtemTemplate.runes.length.toString();
        inputElement.parentNode.remove() //remove from UI

        //since the index is removed, array elements index have been reduced by one to fill the gap, so we start from the index itself until the end
        for (let i = index; i < currentPtemTemplate.runes.length; i++) {
            let oldId = i + 1;
            let newId = i;
            let elem = document.getElementById('srune-' + oldId);
            let textElem = document.getElementById('srune-number-' + oldId);
            elem.id = 'srune-' + newId.toString();
            elem.dataset.sruneid = newId.toString();
            textElem.id = 'srune-number-' + newId.toString();
            textElem.innerHTML = generatePlotGroupNumberText(newId + 1);
        }
    }

    function ptemNft5Changed(inputElement) {
        ptemNftChanged("nft5perc");
    }

    function ptemNft10Changed(inputElement) {
        ptemNftChanged("nft10perc");
    }

    function ptemNft15Changed(inputElement) {
        ptemNftChanged("nft15perc");
    }

    function ptemNftChanged(nftIdentifier) {
        currentPtemTemplate.nftGroup[nftIdentifier] = parseInt(document.getElementById('ptem-'+nftIdentifier).value);
        currentPtemTemplate.nftCount = countNfts(currentPtemTemplate.nftGroup)
        ptemTotalNfts.innerText = currentPtemTemplate.nftCount.toString();
    }

    function generatePlotGroupEditUI(num, plotCount, createDate, decayDate) {
        let deleteButtonHtml = '<span onclick="ptemDeletePlotGroup(this)" class="ptem-delete"></span>';
        let numberText = generatePlotGroupNumberText(num + 1)
        return  `
            <div id="pgroup-${num}" data-pgroupid="${num}" class="ptem-plot-group">
                <span id="pgroup-number-${num}" style="font-size: 1.2rem;">${numberText}</span> <input min="1" onchange="ptemPlotCountChanged(this)" type="number" class="ptem-plotcount" value="${plotCount}"/> - <input onchange="ptemPlotCreatedAtChanged(this)" class="plot-created-at ptem-datepicker" type="date" value="${createDate}"/> - <input onchange="ptemPlotExpiresAtChanged(this)" class="plot-decay-at ptem-datepicker"  type="date" value="${decayDate}"/> ${deleteButtonHtml}
            </div>
        `;
    }

    function generateStoneEditUI(num, createDate, decayDate) {
        let deleteButtonHtml = '<span onclick="ptemDeleteStone(this)" class="ptem-delete"></span>';
        let numberText = generatePlotGroupNumberText(num + 1)
        return  `
            <div id="sstone-${num}" data-sstoneid="${num}" class="ptem-plot-group">
                <span id="sstone-number-${num}" style="font-size: 1.2rem;">${numberText}</span> <input onchange="ptemStoneCreatedAtChanged(this)" class="stone-created-at ptem-datepicker" type="date" value="${createDate}"/> - <input onchange="ptemStoneExpiresAtChanged(this)" class="stone-decay-at ptem-datepicker"  type="date" value="${decayDate}"/> ${deleteButtonHtml}
            </div>
        `;
    }

    function generateRuneEditUI(num, createDate, decayDate) {
        let deleteButtonHtml = '<span onclick="ptemDeleteRune(this)" class="ptem-delete"></span>';
        let numberText = generatePlotGroupNumberText(num + 1)
        return  `
            <div id="srune-${num}" data-sruneid="${num}" class="ptem-plot-group">
                <span id="srune-number-${num}" style="font-size: 1.2rem;">${numberText}</span> <input onchange="ptemRuneCreatedAtChanged(this)" class="rune-created-at ptem-datepicker" type="date" value="${createDate}"/> - <input onchange="ptemRuneExpiresAtChanged(this)" class="rune-decay-at ptem-datepicker"  type="date" value="${decayDate}"/> ${deleteButtonHtml}
            </div>
        `;
    }

    function generatePlotGroupNumberText(num) {

        let numString = num.toString();
        if(num < 10) {
            numString = '00' + num.toString();
        } else if (num < 100) {
            numString = '0' + num.toString();
        }

        return `${numString}. &nbsp`;
    }

    function copyAndAddDays(initialDate, n) {
        let myNewDate = new Date(initialDate);
        myNewDate.setDate(myNewDate.getDate() + n);
        return myNewDate;
    }

    function assureDateValidity(d) {
        let isValid = d instanceof Date && !isNaN(d);
        if(!isValid) {
            alert('Invalid date!')
            throw new Error('Invalid date!');
        }
    }

    function alertObj(obj) {
        alert(JSON.stringify(obj, null, 2))
    }

    function createPlotGroupFromExpiration(expireDate, count) {
        return {
            'createdAt': copyAndAddDays(expireDate, -PLOT_DECAY),
            'expiresAt': expireDate,
            'count': count
        }
    }

    function createPlotGroupFromCreation(creationDate, count) {
        return {
            'createdAt': creationDate,
            'expiresAt': copyAndAddDays(creationDate, PLOT_DECAY),
            'count': count
        }
    }

    function createStoneFromCreation(creationDate) {
        return {
            'createdAt': creationDate,
            'expiresAt': copyAndAddDays(creationDate, STONE_DECAY),
        }
    }

    function createStoneFromExpiration(expireDate) {
        return {
            'createdAt': copyAndAddDays(expireDate, -STONE_DECAY),
            'expiresAt': expireDate,
        }
    }

    function createRuneFromCreation(creationDate) {
        return {
            'createdAt': creationDate,
            'expiresAt': copyAndAddDays(creationDate, RUNE_DECAY),
        }
    }

    function createRuneFromExpiration(expireDate) {
        return {
            'createdAt': copyAndAddDays(expireDate, -RUNE_DECAY),
            'expiresAt': expireDate,
        }
    }

    function createSettingsTemplate(
        //todo: add more params to make the calc more generalized.. reward amount (def 0.25), reward frequency in seconds (def 21600),
        // plot longevity in days (def 300), token price (def $100), sell tax (def 10%) etc..
        name,
        compoundingToSellRatio,
        useSmartCompounding,
        avgPlotCreationDelayInDays
    ) {
        return {
            'name': name,
            'compoundingToSellRatio': compoundingToSellRatio,
            'useSmartCompounding': useSmartCompounding, //means that we first claim to compound, and only then sell
            'avgPlotCreationDelayInHours': avgPlotCreationDelayInDays,
        }
    }

    function createPlotTemplate(plotGroups, stones, runes, nftGroup, name) {
        let nftCount = 0;
        if(nftGroup !== undefined) {
            nftCount =
                parseInt('nft5perc' in nftGroup ? nftGroup['nft5perc'] : 0) +
                parseInt('nft10perc' in nftGroup ? nftGroup['nft10perc'] : 0) +
                parseInt('nft15perc' in nftGroup ? nftGroup['nft15perc'] : 0);
        }
        return {
            'plotGroups': plotGroups,
            'stones': stones,
            'runes': runes,
            'nftGroup': nftGroup,
            'name': name,
            'plotCount': countPlots(plotGroups),
            'nftCount': nftCount
        }
    }

    function createEmptyNftGroup() {
        return createNftGroup(0, 0, 0)
    }

    function createNftGroup(nft5perc, nft10perc, nft15perc) {
        return {
            'nft5perc': nft5perc,
            'nft10perc': nft10perc,
            'nft15perc': nft15perc,
        }
    }

    function smartRound(num, decimalPrecision) { //god i hate JS
        let mult = 10 ** decimalPrecision;
        return Math.round((num + Number.EPSILON) * mult) / mult;
    }

    function dateOnlyString(date) { //god i hate JS even more
        return new Date(date.getTime() - (date.getTimezoneOffset() * 60000 ))
            .toISOString()
            .split("T")[0];
    }

    function clone(obj) { //.. makes me happy i dont usually work in JS
        if (obj === null || typeof (obj) !== 'object' || 'isActiveClone' in obj)
            return obj;

        if (obj instanceof Date)
            return new Date(obj); //or new Date(obj);
        else
            var temp = obj.constructor();

        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                obj['isActiveClone'] = null;
                temp[key] = clone(obj[key]);
                delete obj['isActiveClone'];
            }
        }
        return temp;
    }

    function isEmpty(obj) { //another 'I hate JS' instance.. cant they offer this in the standard lib? kill me
        return Object.keys(obj).length === 0;
    }

    function prepareApplicableNfts(plotCount, nftGroup) {
        let applicableNftGroup = createEmptyNftGroup()
        let nftsApplicable = plotCount;
        if(plotCount > 0) {
            //first exhaust highest paying NFTs

            if(nftGroup.nft15perc < nftsApplicable) { //if we have less 15% NFTs than whats applicable
                applicableNftGroup.nft15perc = nftGroup.nft15perc
                nftsApplicable -= nftGroup.nft15perc

                if(nftGroup.nft10perc < nftsApplicable) { //if we have less 10% NFTs than whats applicable
                    applicableNftGroup.nft10perc = nftGroup.nft10perc
                    nftsApplicable -= nftGroup.nft10perc

                    if(nftGroup.nft5perc < nftsApplicable) { //if we have less 10% NFTs than whats applicable
                        applicableNftGroup.nft5perc = nftGroup.nft5perc
                        nftsApplicable -= nftGroup.nft5perc


                    } else { //if we have more NFTs than whats applicable, we will apply only as many as are applicable
                        applicableNftGroup.nft5perc = nftsApplicable;
                    }


                } else { //if we have more NFTs than whats applicable, we will apply only as many as are applicable
                    applicableNftGroup.nft10perc = nftsApplicable;
                }


            } else { //if we have more NFTs than whats applicable, we will apply only as many as are applicable
                applicableNftGroup.nft15perc = nftsApplicable;
            }

        }

        return applicableNftGroup;
    }

    function calculateNftDailyReward(applicableNftGroup)
    {
        return applicableNftGroup.nft5perc * 0.005 + applicableNftGroup.nft10perc * 0.01 + applicableNftGroup.nft15perc * 0.015;
    }

    function confirmNftCountTest(nftGroup, nft5perc, nft10perc, nft15perc) {
        if(nftGroup.nft5perc !== nft5perc) {
            console.log('failed perc5 test', nftGroup, nft5perc);
        }
        if(nftGroup.nft10perc !== nft10perc) {
            console.log('failed perc10 test', nftGroup, nft10perc);
        }
        if(nftGroup.nft15perc !== nft15perc) {
            console.log('failed perc15 test', nftGroup, nft15perc);
        }
    }

    //just quick test because i'm writing this late and my brain cant simulate prepareApplicableNfts logic atm
    function testPrepareApplicableNfts() {
        let applicableNftTest1 = prepareApplicableNfts(5, createNftGroup(0, 0, 4))
        confirmNftCountTest(applicableNftTest1, 0, 0, 4)

        let applicableNftTest2 = prepareApplicableNfts(5, createNftGroup(1, 2, 7))
        confirmNftCountTest(applicableNftTest2, 0, 0, 5)

        let applicableNftTest3 = prepareApplicableNfts(8, createNftGroup(1, 2, 7))
        confirmNftCountTest(applicableNftTest3, 0, 1, 7)

        let applicableNftTest4 = prepareApplicableNfts(9, createNftGroup(1, 2, 7))
        confirmNftCountTest(applicableNftTest4, 0, 2, 7)

        let applicableNftTest5 = prepareApplicableNfts(10, createNftGroup(1, 2, 7))
        confirmNftCountTest(applicableNftTest5, 1, 2, 7)

        let applicableNftTest6 = prepareApplicableNfts(11, createNftGroup(1, 2, 7))
        confirmNftCountTest(applicableNftTest6, 1, 2, 7)
    }
    testPrepareApplicableNfts()

    function calculate(
        plotTemplate,
        settingsTemplate,
        startFromDate,
        calculateDays,
        claimable,
        plotHardcap,
        stoneHardcap,
        runeHardcap,
        invested,
        cashedOutAlready,
        selectedStrategy,
        buyingPriority
    ) {
        let dateIterator = new Date(startFromDate);


        let activePlots = Object.assign({}, plotTemplate);
        let decayedPlotGroups = [];
        let decayedStones = [];
        let decayedRunes = [];
        let month = 69; //crazy value to make it print once as soon as it starts
        let calculatedData = [];
        let nftRewardSum = 0;
        let dollarAlreadyCashedOutWithoutTax = (cashedOutAlready * 1.11111111)
        let totalHordeCashedOut = dollarAlreadyCashedOutWithoutTax / HORDE_CURRENT_MIDDLE_PRICE;
        let breakEvenStrategyActive = selectedStrategy === STRATEGY_CASHOUT_BREAKEVEN

        for(let i = 0; i < calculateDays; i++) {
            let hordeCashedOut = 0;
            let isLastLoop = (i + 1) === calculateDays;
            let survivingGroups = [];
            let plotCountBeforeDecay = 0;
            activePlots.plotGroups.forEach(item => {
                claimable += (0.1 * item.count)
                plotCountBeforeDecay += item.count

                if(dateIterator < item.expiresAt) {
                    survivingGroups.push(item)
                } else {
                    decayedPlotGroups.push(item);
                }
            })
            let nftReward = calculateNftDailyReward(prepareApplicableNfts(plotCountBeforeDecay, plotTemplate.nftGroup))
            claimable += nftReward
            nftRewardSum += nftReward

            let survivingStones = [];
            let stonesCountBeforeDecay = 0;

            activePlots.stones.forEach(item => {
                claimable += 0.05
                stonesCountBeforeDecay += 1

                if(dateIterator < item.expiresAt) {
                    survivingStones.push(item)
                } else {
                    decayedStones.push(item);
                }
            })

            let survivingRunes = [];
            let runesCountBeforeDecay = 0;

            activePlots.runes.forEach(item => {
                claimable += 0.01
                runesCountBeforeDecay += 1

                if(dateIterator < item.expiresAt) {
                    survivingRunes.push(item)
                } else {
                    decayedRunes.push(item);
                }
            })

            let decayedPlotCount = countPlots(decayedPlotGroups);
            let decayedStoneCount = decayedStones.length;
            let decayedRuneCount = decayedRunes.length;
            let activePlotCount = countPlots(survivingGroups); //hmm
            let activeStoneCount = survivingStones.length;
            let activeRuneCount = survivingRunes.length;
            let dailyHordeGeneration = smartRound(activePlotCount * 0.1 + activeStoneCount * 0.05 + activeRuneCount * 0.01, 2);
            let dailyDollarGeneration = smartRound(dailyHordeGeneration * HORDE_CURRENT_MIDDLE_PRICE, 2);
            let dateOnlyAsString = dateOnlyString(dateIterator);
            //print every month (or last date)
            if(month !== dateIterator.getMonth() ||  isLastLoop) {
                month = dateIterator.getMonth();
            }

            if(breakEvenStrategyActive) {
                let cashedOutDollarTotal = totalHordeCashedOut * HORDE_CURRENT_MIDDLE_PRICE * 0.9;
                let leftToBreakEven = invested - cashedOutDollarTotal;
                if(leftToBreakEven > 0) { //if we have not broken even, do a full cashout
                    hordeCashedOut = claimable;
                    claimable = 0;
                } else {
                    breakEvenStrategyActive = false; //we have cashed out, so we stop the strategy
                }
            }

            ////BUYING/CREATION!!!!
            let activePlotCountAfterCreation = activePlotCount;
            let activeStoneCountAfterCreation = activeStoneCount;
            let activeRuneCountAfterCreation = activeRuneCount;



            let haveMaxPlots = !('plots' in buyingPriority) || activePlotCountAfterCreation >= plotHardcap;
            let haveMaxStones = !('stones' in buyingPriority) || activeStoneCountAfterCreation >= stoneHardcap;

            //console.log(`===== buying stuff =====`);
            for(let priorityCounter = 1; priorityCounter <= 3; priorityCounter++) {
                for(const key in buyingPriority) {
                    //nested loop needed to execute in given priority
                    if (buyingPriority.hasOwnProperty(key) && buyingPriority[key] === priorityCounter) {
                        //we have a prio match
                        if(key === 'plots') {

                            let plotsToCreate = 0;
                            //console.log(`doing plots`);
                            //if we have enough to create a plot(s), we create
                            while(claimable >= 10 && activePlotCountAfterCreation < plotHardcap) {
                                claimable -= 10;
                                plotsToCreate++;
                                activePlotCountAfterCreation++;
                            }

                            if(plotsToCreate !== 0) {
                                survivingGroups.push(
                                    createPlotGroupFromCreation(
                                        new Date(dateIterator),
                                        plotsToCreate
                                    )
                                )
                            }
                            //recalculating haveMaxPlots because the numbers changed
                            haveMaxPlots = (!('plots' in buyingPriority) || activePlotCountAfterCreation >= plotHardcap)
                        } else if (key === 'stones') {
                            //console.log(`doing stones`);

                            //since stones need less claimable horde than plots, even if plot prio is 1 and stones are 2,
                            // stones will get created because if we have i.e. 6 horde plot cant be created so in next
                            // loop stone is created.. therefore we need to add an additional check

                            if('plots' in buyingPriority && buyingPriority['plots'] < buyingPriority['stones'] && haveMaxPlots === false) {
                                continue;
                            }

                            while(claimable >= 5 && activeStoneCountAfterCreation < stoneHardcap) {
                                claimable -= 5;
                                survivingStones.push(createStoneFromCreation(new Date(dateIterator)))
                                activeStoneCountAfterCreation++;
                            }
                            haveMaxStones = !('stones' in buyingPriority) || activeStoneCountAfterCreation >= stoneHardcap;
                        } else if (key === 'runes') {
                            //console.log(`doing runes`);

                            //same like for stones, but this time we have to check plots and stones

                            if(
                                'plots' in buyingPriority && buyingPriority['plots'] < buyingPriority['stones'] && haveMaxPlots === false
                                && 'stones' in buyingPriority && buyingPriority['stones'] < buyingPriority['runes'] && haveMaxStones === false
                            ) {
                                continue;
                            }

                            while(claimable >= 1 && activeRuneCountAfterCreation < runeHardcap) {
                                claimable -= 1;
                                survivingRunes.push(createRuneFromCreation(new Date(dateIterator)))
                                activeRuneCountAfterCreation++;
                            }
                        }
                    }
                }
            }

            if(survivingGroups.length === 0 && survivingStones.length === 0 && survivingRunes.length === 0) {
                break;
            }

            let ceilingIsHit =
                (!('plots' in buyingPriority) || activePlotCountAfterCreation >= plotHardcap)
                && (!('stones' in buyingPriority) || activeStoneCountAfterCreation >= stoneHardcap)
                && (!('runes' in buyingPriority) || activeRuneCountAfterCreation >= runeHardcap)
            ;
            if(ceilingIsHit) {
                //if ceiling is hit, no strategy can be done except keep at least 10 tokens (to fill the gap in next day if a plot decays) and claim the rest
                if(claimable > 10) {
                    hordeCashedOut = claimable - 10;
                    claimable -= hordeCashedOut;
                }
            } else {
                //do selected strategy
            }

            totalHordeCashedOut += hordeCashedOut;

            calculatedData.push(
                {
                    day: (i + 1),
                    date: dateOnlyAsString,
                    activePlots: activePlotCountAfterCreation,
                    activeStones: activeStoneCountAfterCreation,
                    activeRunes: activeRuneCountAfterCreation,
                    decayedPlots: decayedPlotCount,
                    decayedStones: decayedStoneCount,
                    decayedRunes: decayedRuneCount,
                    dailyHorde: dailyHordeGeneration,
                    dailyDollar: dailyDollarGeneration,
                    totalHordeCashedOut: totalHordeCashedOut,
                    hordeCashedOut: hordeCashedOut,
                    totalDollarCashedOut: totalHordeCashedOut * HORDE_CURRENT_MIDDLE_PRICE * 0.9,
                    totalDollarTaxed: totalHordeCashedOut * HORDE_CURRENT_MIDDLE_PRICE * 0.1,
                    dailyDollarCashedOut: hordeCashedOut * HORDE_CURRENT_MIDDLE_PRICE * 0.9,
                    dailyDollarTaxed: hordeCashedOut * HORDE_CURRENT_MIDDLE_PRICE * 0.1,
                }
            )
            activePlots.plotGroups = survivingGroups;
            activePlots.stones = survivingStones;
            activePlots.runes = survivingRunes;
            dateIterator = copyAndAddDays(dateIterator, 1);
        }

        return calculatedData;
    }

    function oldCalculate(plotTemplate, settingsTemplate, startFromDate, calculateDays, claimable) {
        let dateIterator = new Date(startFromDate);

        let activePlots = Object.assign({}, plotTemplate);
        let decayedPlotGroups = [];
        let month = 69; //crazy value to make it print once as soon as it starts
        let results = ''; //
        let calculatedData = [];


        for(let i = 0; i < calculateDays; i++) {
            let isLastLoop = (i + 1) === calculateDays;
            let survivingGroups = [];
            activePlots.plotGroups.forEach(item => {
                claimable += (0.1 * item.count)

                if(dateIterator < item.expiresAt) {
                    survivingGroups.push(item)
                } else {
                    decayedPlotGroups.push(item);
                }
            })

            let decayedPlotCount = countPlots(decayedPlotGroups);
            let activePlotCount = countPlots(activePlots.plotGroups);
            let dailyHordeGeneration = smartRound(activePlotCount * 0.1, 2);
            let dailyDollarGeneration = smartRound(dailyHordeGeneration * 100, 2);
            let dateOnlyAsString = dateOnlyString(dateIterator);
            //print every month (or last date)
            if(month !== dateIterator.getMonth() ||  isLastLoop) {
                month = dateIterator.getMonth();
                if(isLastLoop) {
                    results += "<h4>Result on last day</h4>" + "<br>";
                }
                results += "State at  " + dateOnlyAsString + "<br>";
                //results += "&nbsp&nbsp&nbsp&nbspClaimable: " + smartRound(claimable, 2).toString() + "<br>"; //makes no sense to print in a monthly printout
                results += "&nbsp&nbsp&nbsp&nbspDay: " + (i + 1).toString() + "<br>";
                results += "&nbsp&nbsp&nbsp&nbspPlots: " + activePlotCount.toString() + "<br>";
                results += "&nbsp&nbsp&nbsp&nbspDaily token generation: " + smartRound(dailyHordeGeneration, 2) + "<br>";
                results += "&nbsp&nbsp&nbsp&nbspDaily dollar generation: $" + smartRound(dailyDollarGeneration, 2).toString() + "<br>";
                results += "&nbsp&nbsp&nbsp&nbspDecayed plots: " + decayedPlotCount + "<br>";
                results += "<br>";

            }

            //if we have enough to create a plot(s), we create
            let plotsToCreate = 0;
            while(claimable >= 10) {
                claimable -= 10;
                plotsToCreate++;
            }

            if(plotsToCreate !== 0) {
                survivingGroups.push(
                    createPlotGroupFromCreation(
                        new Date(dateIterator),
                        plotsToCreate
                    )
                )
            }

            if(survivingGroups.length === 0) {
                results += "On day " + (i + 1).toString() + " you've run out of plots, because you sold too much!"
                break;
            }

            calculatedData.push(
                {
                    day: (i + 1),
                    date: dateOnlyAsString,
                    activePlots: activePlotCount,
                    decayedPlots: decayedPlotCount,
                    dailyHorde: dailyHordeGeneration,
                    dailyDollar: dailyDollarGeneration
                }
            )
            activePlots.plotGroups = survivingGroups;
            dateIterator = copyAndAddDays(dateIterator, 1);
        }

        document.getElementById("monthly-results-raw").innerHTML = results

        return calculatedData;
    }

    function countPlots(plotGroups) {
        let sum = 0;
        for(let i = 0; i < plotGroups.length; i++) {
            sum += plotGroups[i].count;
        }

        return sum;
    }

    function countNfts(nftGroup) {
        return nftGroup.nft5perc + nftGroup.nft10perc + nftGroup.nft15perc;
    }

    let OLD_ACTIVE_PLOT_CHART = null;
    let ACTIVE_PLOT_CHART = null;
    let HORDE_INCOME_CHART = null;
    let CASHOUT_CHART = null;
    let TOKENOMICS_CHART = null;
    let TOKENOMICS_CHART_DOLLARS = null;

    let ACTIVE_ZNFT_MONTHLY_CHART = null;
    let ACTIVE_ZNFT_USER_CHART = null;

    function runZnftCalculation() {

        let znft_calculator_user_rarity_score = parseInt(document.getElementById("znft_calculator_user_rarity_score").value)
        let znft_calculator_invested = parseInt(document.getElementById("znft_calculator_invested").value)
        let znft_calculator_months = parseInt(document.getElementById("znft_calculator_months").value)
        let znft_calculator_system_rarity_score = parseInt(document.getElementById("znft_calculator_system_rarity_score").value)
        let znft_calculator_minted_left = parseInt(document.getElementById("znft_calculator_minted_left").value)
        let znft_calculator_bot_monthly_roi = parseInt(document.getElementById("znft_calculator_bot_monthly_roi").value)

        GLOBAL_DATA.znft_inputs.znft_calculator_user_rarity_score = znft_calculator_user_rarity_score;
        GLOBAL_DATA.znft_inputs.znft_calculator_invested = znft_calculator_invested;
        GLOBAL_DATA.znft_inputs.znft_calculator_months = znft_calculator_months;
        GLOBAL_DATA.znft_inputs.znft_calculator_system_rarity_score = znft_calculator_system_rarity_score;
        GLOBAL_DATA.znft_inputs.znft_calculator_minted_left = znft_calculator_minted_left;
        //dont remember bot monthly roi, might be problems about people assuming numbers
        writeToLocalStorage(GLOBAL_DATA)
        let todayDate = new Date();
        let totalInvested = (ZNFT_MAX_COUNT - znft_calculator_minted_left) * 400;

        if(znft_calculator_bot_monthly_roi <= 0) {

            document.getElementById("znft-calculation-results").style.display = 'none';
            document.getElementById("znft-calculator-noroi-message").style.display = 'block';
        } else {

            //TODO: later initial bot funds will be dynamic because of auto-compound, fetch it from some horde API or ask for user input instead of number of minted
            let totalBotFunds = totalInvested * ZNFT_BOT_SHARE_OF_FUNDS;
            document.getElementById("znft_result_bot_initial_funds").innerHTML =  "$" + totalBotFunds;

            let userRSShare = znft_calculator_user_rarity_score /  znft_calculator_system_rarity_score;
            document.getElementById("znft_result_user_rs_share").innerHTML =  smartRound((userRSShare * 100), 7) + "%";

            let calculatedData = calculateZnft(
                userRSShare,
                znft_calculator_invested,
                totalBotFunds,
                znft_calculator_months,
                todayDate,
                (znft_calculator_bot_monthly_roi / 100)
            )


            plotZnftUserGraph(calculatedData, "znftCalculatorUserProfits");
            plotZnftMonthlyGraph(calculatedData, "znftCalculatorMonthlyProfits");

            document.getElementById("znft-calculation-results").style.display = 'block';
            document.getElementById("znft-calculator-noroi-message").style.display = 'none';
        }

    }

    function calculateZnft(userRSShare, userInvested, totalBotFunds, months, todayDate, monthlyBotRoi) {
        if(months < 0) {
            return {};
        }



        let botFunds = totalBotFunds;
        let totalBotShare = 0;
        let totalLMShare = 0;
        let totalHordePoolShare = 0;
        let totalHoldersShare = 0;

        let totalUserShare = userInvested;
        let totalUserRoi = 100;
        let calculatedData = [];
        let loopDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), 1);
        for(let i = 0; i < months; i++) {
            loopDate.setMonth(loopDate.getMonth()+1)
            let profit = botFunds * monthlyBotRoi;

            let botShare = profit * ZNFT_BOT_PROFIT_COMPOUND_SHARE;
            let lmShare = profit * ZNFT_BOT_PROFIT_LM_SHARE;
            let hordePoolShare = profit * ZNFT_BOT_PROFIT_HORDE_POOL_SHARE;
            let holdersShare = profit * ZNFT_BOT_PROFIT_HOLDERS_SHARE;
            let userShare = holdersShare * userRSShare;

            totalBotShare += botShare;
            totalLMShare += lmShare;
            totalHordePoolShare += hordePoolShare;
            totalHoldersShare += holdersShare;
            totalUserShare += userShare;

            let botFundsDuringMonth = botFunds; //bot funds are compounded with its share of profits
            botFunds += botShare; //bot funds are compounded with its share of profits

            let endOfMonth = new Date(loopDate);
            endOfMonth.setDate(endOfMonth.getDate() - 1);

            let thisMonthUserRoi = (userShare / userInvested) * 100;
            totalUserRoi += thisMonthUserRoi;
            calculatedData.push({
                "botFundsDuringMonth" : botFundsDuringMonth,
                "botFundsEndOfMonth" : botFunds,
                "botShare" : botShare,
                "lmShare" : lmShare,
                "hordePoolShare" : hordePoolShare,
                "holdersShare" : holdersShare,
                "userShare" : userShare,

                //calculated
                "thisMonthUserRoi": thisMonthUserRoi,
                "totalUserRoi": totalUserRoi,

                //date
                "monthOrdinal": i,
                "date": endOfMonth,
                "dateOnlyString": dateOnlyString(endOfMonth),


                //totals
                "totalBotShare" : totalBotShare,
                "totalLMShare" : totalLMShare,
                "totalHordePoolShare" : totalHordePoolShare,
                "totalHoldersShare" : totalHoldersShare,
                "totalUserShare" : totalUserShare,
            })
        }

        let totals = {
            "botFunds" : botFunds,
            "totalBotShare" : totalBotShare,
            "totalLMShare" : totalLMShare,
            "totalHordePoolShare" : totalHordePoolShare,
            "totalHoldersShare" : totalHoldersShare,
            "totalUserShare" : totalUserShare,
        }

        console.log("calculatedData", calculatedData);
        console.log("totals", totals);

        return calculatedData;
    }

    function plotZnftMonthlyGraph(calculatedData, plotCanvasId) {
        if (ACTIVE_ZNFT_MONTHLY_CHART !== null) {
            ACTIVE_ZNFT_MONTHLY_CHART.destroy()
        }
        let ctx = document.getElementById(plotCanvasId);
        ACTIVE_ZNFT_MONTHLY_CHART = plotChart(
            ctx,
            [
                {
                    label: 'HordePool Share',
                    data: calculatedData,
                    borderColor:'#17C139',
                    backgroundColor:'rgba(23, 193, 57, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'hordePoolShare'
                    }
                },
                {
                    label: 'Compound Share',
                    data: calculatedData,
                    borderColor:'#6C0EB6',
                    backgroundColor: 'rgba(108, 14, 182, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'botShare'
                    }
                },
                {
                    label: 'LM Share',
                    data: calculatedData,
                    borderColor:'#F7C139',
                    backgroundColor: 'rgba(247, 193, 57, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'lmShare'
                    }
                },
                {
                    label: 'Holders Share',
                    data: calculatedData,
                    borderColor:'rgba(150, 30, 50, 1)',
                    backgroundColor:'rgba(200, 30, 50, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'holdersShare'
                    }
                },
                {
                    label: 'HordePool Share - CUMULATIVE',
                    data: calculatedData,
                    borderColor:'#17C139',
                    backgroundColor:'rgba(23, 193, 57, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'totalHordePoolShare'
                    },
                    hidden: true
                },
                {
                    label: 'Compound Share - CUMULATIVE',
                    data: calculatedData,
                    borderColor:'#6C0EB6',
                    backgroundColor: 'rgba(108, 14, 182, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'totalBotShare'
                    },
                    hidden: true
                },
                {
                    label: 'LM Share - CUMULATIVE',
                    data: calculatedData,
                    borderColor:'#F7C139',
                    backgroundColor: 'rgba(247, 193, 57, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'totalLMShare'
                    },
                    hidden: true
                },
                {
                    label: 'Holders Share - CUMULATIVE',
                    data: calculatedData,
                    borderColor:'rgba(150, 30, 50, 1)',
                    backgroundColor:'rgba(200, 30, 50, 1)',
                    borderWidth: 1,
                    pointBorderWidth: 1,
                    pointRadius: 1,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'totalHoldersShare'
                    },
                    hidden: true
                },
            ],
            true
        );

    }

    function plotZnftUserGraph(calculatedData, plotCanvasId) {
        if (ACTIVE_ZNFT_USER_CHART !== null) {
            ACTIVE_ZNFT_USER_CHART.destroy()
        }
        let ctx = document.getElementById(plotCanvasId);
        ACTIVE_ZNFT_USER_CHART = plotChart(
            ctx,
            [
                {
                    label: 'Profit in $$$',
                    data: calculatedData,
                    borderColor:'#17C139',
                    backgroundColor:'rgba(16, 138, 40, 1)',
                    borderWidth: 5,
                    pointBorderWidth: 3,
                    pointRadius: 3,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'userShare'
                    },
                    hidden: true
                },
                {
                    label: 'ROI perc',
                    data: calculatedData,
                    borderColor:'rgba(75, 10, 127, 1)',
                    backgroundColor: 'rgba(108, 14, 182, 1)',
                    borderWidth: 5,
                    pointBorderWidth: 3,
                    pointRadius: 3,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'thisMonthUserRoi'
                    },
                    hidden: true
                },
                {
                    label: 'Profit - CUMULATIVE',
                    data: calculatedData,
                    borderColor:'rgba(172, 135, 40, 1)',
                    backgroundColor: 'rgba(247, 193, 57, 1)',
                    borderWidth: 5,
                    pointBorderWidth: 3,
                    pointRadius: 3,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'totalUserShare'
                    }
                },
                {
                    label: 'ROI perc - CUMULATIVE',
                    data: calculatedData,
                    borderColor:'rgba(150, 30, 50, 1)',
                    backgroundColor:'rgba(200, 30, 50, 1)',
                    borderWidth: 5,
                    pointBorderWidth: 3,
                    pointRadius: 3,
                    fill: true,
                    parsing: {
                        xAxisKey: 'dateOnlyString',
                        yAxisKey: 'totalUserRoi'
                    },
                    hidden: true
                },
            ],
            true
        );
    }

    function runCalculation() {
        hideCalculatorError()
        if(!userHasTemplates()) {
            return;
        }
        let templateName = calculatorTemplatesSelect.value;
        let template = null;
        if(templateName === LIVE_WALLET_TEMPLATE_NAME || templateName === LIVE_WALLET_TEMPLATE_NAME_EDITED) {
            template = templateFromInput;
        } else {
            template = GLOBAL_DATA.templates[templateName]
        }
        console.log()
        let settingsTemplate = createSettingsTemplate(
            'justname',
            1,
            true,
            3
        )

        let numOfClaimable = parseInt(document.getElementById("calculator_num_of_claimable").value)
        let numOfDaysInFuture = parseInt(document.getElementById("calculator_num_of_days_in_future").value)
        let walletsHardcap = parseInt(document.getElementById("calculator_wallets_hardcap").value)
        let plotHardcap = walletsHardcap * 100
        let stoneHardcap = walletsHardcap * 2
        let runeHardcap = walletsHardcap * 10
        let invested = parseFloat(document.getElementById("calculator_invested").value)
        let cashedOutAlready = parseFloat(document.getElementById("calculator_cashed_out_already").value)
        let strategy = getSelectedStrategy()

        if(strategy === STRATEGY_CASHOUT_BREAKEVEN && invested <= 0) {
            showCalculatorError('Cant do breakeven strategy if you dont input your investment $$$!')
            return;
        }

        if(numOfDaysInFuture < 2) {
            return;
        }
        GLOBAL_DATA.inputs.duration_in_future = numOfDaysInFuture;
        GLOBAL_DATA.inputs.wallets_hardcap = walletsHardcap;
        GLOBAL_DATA.inputs.invested = invested;
        GLOBAL_DATA.inputs.cashed_out_already = cashedOutAlready;
        GLOBAL_DATA.inputs.chosen_strategy = strategy;
        writeToLocalStorage(GLOBAL_DATA)
        let todayDate = new Date();

        let buyingPriorities = {}
        if(document.getElementById("calc-plots-checkbox").checked) {
            buyingPriorities.plots = parseInt(document.getElementById("plots-priority").value)
        }
        if(document.getElementById("calc-stones-checkbox").checked) {
            buyingPriorities.stones = parseInt(document.getElementById("stones-priority").value)
        }
        if(document.getElementById("calc-runes-checkbox").checked) {
            buyingPriorities.runes = parseInt(document.getElementById("runes-priority").value)
        }

        let calculatedData = calculate(
            template,
            settingsTemplate,
            todayDate,
            numOfDaysInFuture,
            numOfClaimable,
            plotHardcap,
            stoneHardcap,
            runeHardcap,
            invested,
            cashedOutAlready,
            strategy,
            buyingPriorities
        )

        plotPlotGraph(calculatedData, 'calculatorActivePlotsGraph');
        plotHordeIncomeChart(calculatedData, 'calculatorHordeIncomeGraph');
        plotCashoutChart(calculatedData, 'calculatorCashoutGraph', invested, cashedOutAlready);
        plotTokenomicsChart(calculatedData, 'calculatorTokenomicsGraph');
        plotTokenomicsChart(calculatedData, 'calculatorTokenomicsDollarsGraph', true, HORDE_CURRENT_MIDDLE_PRICE);
        document.getElementById("results").style.display = 'block';
    }

    function runSimpleCalculation() {

        let todayDate = new Date();
        let decayDate = copyAndAddDays(todayDate, PLOT_DECAY);

        let numOfPlots = parseInt(document.getElementById("scalc_num_of_plots").value)
        let numOfClaimable = parseInt(document.getElementById("scalc_num_of_claimable").value)
        let numOfDaysInFuture = parseInt(document.getElementById("scalc_num_of_days_in_future").value)

        let settingsTemplate = createSettingsTemplate(
            'justname',
            1,
            true,
            3
        )

        let plotTemplate = createPlotTemplate([createPlotGroupFromExpiration(decayDate, numOfPlots)], [], [], createEmptyNftGroup(), 'simple');
        let calculatedData = oldCalculate(plotTemplate, settingsTemplate, todayDate, numOfDaysInFuture, numOfClaimable)

        oldPlotPlotGraph(calculatedData, 'scalcActivePlotsGraph');
        document.getElementById("results").style.display = 'block';
    }

    function plotPlotGraph(calculatedData, plotCanvasId) {
        if (ACTIVE_PLOT_CHART !== null) {
            ACTIVE_PLOT_CHART.destroy()
        }
        let ctx = document.getElementById(plotCanvasId);
        ACTIVE_PLOT_CHART = plotChart(
            ctx,
            [{
                label: 'Decayed Plots',
                data: calculatedData,
                borderColor:'#6C0EB6',
                backgroundColor: 'rgba(108, 14, 182, 1)',
                borderWidth: 3,
                pointBorderWidth: 0,
                pointRadius: 0,
                fill: true,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'decayedPlots'
                }
            },{
                label: 'Decayed Stones',
                data: calculatedData,
                borderColor:'#6c0eb6',
                backgroundColor: 'rgba(44, 12, 122, 1)',
                borderWidth: 2,
                pointBorderWidth: 0,
                pointRadius: 0,
                fill: true,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'decayedStones'
                }
            },{
                label: 'Decayed Runes',
                data: calculatedData,
                borderColor:'rgba(33, 33, 33, 1)',
                backgroundColor: 'rgba(44, 44, 44, 1)',
                borderWidth: 2,
                pointBorderWidth: 0,
                pointRadius: 0,
                fill: true,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'decayedRunes'
                }
            },{
                label: 'Active Runes',
                data: calculatedData,
                borderColor:'rgba(150, 30, 50, 1)',
                backgroundColor:'rgba(200, 30, 50, 1)',
                borderWidth: 2,
                pointBorderWidth: 0,
                pointRadius: 0,
                fill: true,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'activeRunes'
                }
            },{
                label: 'Active Stones',
                data: calculatedData,
                borderColor:'#F7C139',
                backgroundColor: 'rgba(247, 193, 57, 1)',
                borderWidth: 2,
                pointBorderWidth: 0,
                pointRadius: 0,
                fill: true,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'activeStones'
                }
            },{
                label: 'Active Plots',
                data: calculatedData,
                borderColor:'#17C139',
                backgroundColor:'rgba(23, 193, 57, 0.5)',
                borderWidth: 3,
                pointBorderWidth: 0,
                pointRadius: 0,
                fill: true,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'activePlots'
                }
            }],
            true
        );
    }

    function plotHordeIncomeChart(calculatedData, plotCanvasId) {
        let datasets = [{
            label: 'Daily horde generation',
            data: calculatedData,
            borderColor:'rgba(23, 193, 57, 0.5)',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'dailyHorde'
            }
        }];

        if (HORDE_INCOME_CHART !== null) {
            HORDE_INCOME_CHART.destroy()
        }
        let ctx = document.getElementById(plotCanvasId);
        HORDE_INCOME_CHART = plotChart(
            ctx,
            datasets,
            false
        );
    }

    function plotCashoutChart(calculatedData, plotCanvasId, invested, cashedOutAlready) {
        let data = clone(calculatedData)
        /* commented out because the cashedOutAlready is now included in the calculation
            data.forEach(
                (x, i) => {
                    data[i].totalDollarCashedOut = data[i].totalDollarCashedOut + cashedOutAlready
                    data[i].totalDollarTaxed = data[i].totalDollarTaxed + (cashedOutAlready * 0.1111111111) //multiplying cashed out by 0.1111111111 will give how much was taxed
                }
            )
        */

        let datasets = [{
            label: 'Cashout Profit (accumulated)',
            data: data,
            borderColor:'#17C139',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'totalDollarCashedOut'
            }
        },{
            label: 'Cashout Tax (accumulated)',
            data: data,
            borderColor:'#F7C139',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            hidden: true,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'totalDollarTaxed'
            }
        },{
            label: 'Cashout Profit (daily)',
            data: data,
            borderColor:'#6C0EB6',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            hidden: true,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'dailyDollarCashedOut'
            }
        },{
            label: 'Cashout Tax (daily)',
            data: data,
            borderColor:'#FC0EB6',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            hidden: true,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'dailyDollarTaxed'
            }
        }];

        if(invested !== 0) {
            //console.log(invested)
            //console.log(data)
            let firstDate = data[0].date;
            let secondDate = data[data.length - 1].date;
            let investedDataset = [
                {
                    'date': firstDate,
                    'invested': invested
                },
                {
                    'date': secondDate,
                    'invested': invested
                },
            ]
            //console.log(investedDataset)
            datasets.push(
                {
                    label: 'Break Even',
                    data: investedDataset,
                    borderColor:'white',
                    borderWidth: 2,
                    pointBorderWidth: 0,
                    pointRadius: 0,
                    parsing: {
                        xAxisKey: 'date',
                        yAxisKey: 'invested'
                    }
                }
            )
        }

        if (CASHOUT_CHART !== null) {
            CASHOUT_CHART.destroy()
        }
        let ctx = document.getElementById(plotCanvasId);
        CASHOUT_CHART = plotChart(
            ctx,
            datasets,
            false
        );
    }


    function plotTokenomicsChart(calculatedData, plotCanvasId, inDollars, hordeAvgPrice) {
        let data = clone(calculatedData)
        let stringInDollars = '';
        if(inDollars) {
            stringInDollars = ' (in $$$)'
        }
        data.forEach(
            (x, i) => {
                let totalCreatedPlotsHordeValue = (data[i].activePlots + data[i].decayedPlots) * 10;
                if(inDollars) {
                    totalCreatedPlotsHordeValue *= hordeAvgPrice
                }

                //mults have to add up to 1
                data[i].totalBackRewards = totalCreatedPlotsHordeValue * 0.6
                data[i].totalBackTreasury = totalCreatedPlotsHordeValue * 0
                data[i].totalBackLm = totalCreatedPlotsHordeValue * 0.2
                data[i].totalBackHordePool = totalCreatedPlotsHordeValue * 0.2
            }
        )

        let datasets = [{
            label: 'Plot creation HORDE -> horde pool' + stringInDollars,
            data: data,
            borderColor:'#F7C139',
            backgroundColor: 'rgba(247, 193, 57, 1)',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            fill: true,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'totalBackHordePool'
            }
        },{
            label: 'Plot creation HORDE -> treasury' + stringInDollars,
            data: data,
            borderColor:'#6C0EB6',
            backgroundColor: 'rgba(108, 14, 182, 1)',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            fill: true,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'totalBackTreasury'
            }
        },{
            label: 'Plot creation HORDE -> LM' + stringInDollars,
            data: data,
            borderColor:'rgba(150, 30, 50, 1)',
            backgroundColor:'rgba(200, 30, 50, 1)',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            fill: true,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'totalBackLm'
            }
        },{
            label: 'Plot creation HORDE -> rewards' + stringInDollars,
            data: data,
            borderColor:'#17C139',
            backgroundColor:'rgba(23, 193, 57, 1)',
            borderWidth: 3,
            pointBorderWidth: 0,
            pointRadius: 0,
            fill: true,
            parsing: {
                xAxisKey: 'date',
                yAxisKey: 'totalBackRewards'
            }
        }];

        //this is ugly AF but have no mental capacity to make it nice
        if(inDollars) {
            if (TOKENOMICS_CHART_DOLLARS !== null) {
                TOKENOMICS_CHART_DOLLARS.destroy()
            }
            let ctx = document.getElementById(plotCanvasId);
            TOKENOMICS_CHART_DOLLARS = plotChart(
                ctx,
                datasets,
                true
            );
        } else {
            if (TOKENOMICS_CHART !== null) {
                TOKENOMICS_CHART.destroy()
            }
            let ctx = document.getElementById(plotCanvasId);
            TOKENOMICS_CHART = plotChart(
                ctx,
                datasets,
                true
            );
        }
    }


    function plotChart(ctx, datasets, stacked) {
        return  new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                plugins: {  // 'legend' now within object 'plugins {}'
                    legend: {
                        labels: {
                            color: "#dee2e6",  // not 'fontColor:' anymore
                            // fontSize: 18  // not 'fontSize:' anymore
                            font: {
                                size: 12 // 'size' now within object 'font {}'
                            }
                        }
                    }
                },
                responsive:true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    axis: 'x'
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        stacked: stacked,
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    },
                }
            }
        });
    }

    function oldPlotPlotGraph(calculatedData, plotCanvasId) { //plotPlot lmao
        if (OLD_ACTIVE_PLOT_CHART !== null) {
            OLD_ACTIVE_PLOT_CHART.destroy()
        }
        OLD_ACTIVE_PLOT_CHART = oldPlotGraphFromCalcData(document.getElementById(plotCanvasId), calculatedData,
            [{
                label: 'Active Plots',
                data: calculatedData,
                borderColor:'#17C139',
                borderWidth: 1,
                pointBorderWidth: 1,
                pointRadius: 1,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'activePlots'
                }
            }, {
                label: 'Decayed Plots',
                data: calculatedData,
                borderColor:'#6C0EB6',
                borderWidth: 1,
                pointBorderWidth: 1,
                pointRadius: 1,
                parsing: {
                    xAxisKey: 'date',
                    yAxisKey: 'decayedPlots'
                }
            }]);
    }

    function oldPlotGraphFromCalcData(ctx, calculatedData, datasets) {
        return new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                plugins: {  // 'legend' now within object 'plugins {}'
                    legend: {
                        labels: {
                            color: "#dee2e6",  // not 'fontColor:' anymore
                            // fontSize: 18  // not 'fontSize:' anymore
                            font: {
                                size: 12 // 'size' now within object 'font {}'
                            }
                        }
                    }
                },
                responsive:true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    axis: 'x'
                },
                scales: {
                    y: {
                        beginAtZero: false
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    },
                }
            }
        });
    }

    function isJson(item) {
        item = typeof item !== "string"
            ? JSON.stringify(item)
            : item;

        try {
            item = JSON.parse(item);
        } catch (e) {
            return false;
        }

        return typeof item === "object" && item !== null;
    }

    function generateTemplateUICard(plotTemplate, isLiveTemplate, isLiveTemplateEdited, generateEditPencil, generateDeleteButton, generateCopyButton) {
        let editPencilHTML = '';
        if(generateEditPencil) {
            editPencilHTML = `
                <span onclick="openPTEM('${plotTemplate.name}')" class="template-card-pencil"><span class="pencil-img" style="padding: 0.4em;"></span></span>
            `;
        }

        let copyButtonHTML = '';
        if(generateCopyButton) {
            copyButtonHTML = `
                <span onclick="copyTemplate('${plotTemplate.name}')" class="template-card-copy"></span>
            `;
        }

        let deleteButtonHTML = '';
        if(generateDeleteButton) {
            deleteButtonHTML = `
                <span onclick="deleteTemplate('${plotTemplate.name}')" class="template-card-trash"></span>
            `;
        }

        let name = plotTemplate.name;
        if(isLiveTemplate) {
            let text = ' LIVE';
            if(isLiveTemplateEdited) {
                text = ' LIVE (edited) ';
            }
            name = `<span style="padding: 2px 12px 2px 8px; background-color: #6C0EB6">${text}</span>`;
        }

        let headerClass = 'card-header';
        if(plotTemplate.name.length > 18) {
            headerClass = 'card-header-small';
            if(plotTemplate.name.length > 21) {
                headerClass = 'card-header-smaller';
            }
        }



        return `<div class="template-card">
                ${editPencilHTML}
                ${copyButtonHTML}
                ${deleteButtonHTML}
                <div class="${headerClass}">
                    ${name}
                </div>
                <div class="template-card-body">
                    <span class="card-row"><span class="card-row-number">${plotTemplate.plotCount}</span>p | <span class="card-row-number">${plotTemplate.stones.length}</span>s | <span class="card-row-number">${plotTemplate.runes.length}</span>r</span>
                    <span class="card-row"><span class="card-row-number">${plotTemplate.nftCount}</span> NFTs</span>
                </div>
        </div>`;
    }

    function plotsCheckOnChange() {
        if(document.getElementById('calc-plots-checkbox').checked) {
            document.getElementById("plots-priority").style.display = 'inline-block'
        } else {
            document.getElementById("plots-priority").style.display = 'none'
        }
    }

    function stonesCheckOnChange() {
        if(document.getElementById('calc-stones-checkbox').checked) {
            document.getElementById("stones-priority").style.display = 'inline-block'
        } else {
            document.getElementById("stones-priority").style.display = 'none'
        }
    }

    function runesCheckOnChange() {
        if(document.getElementById('calc-runes-checkbox').checked) {
            document.getElementById("runes-priority").style.display = 'inline-block'
        } else {
            document.getElementById("runes-priority").style.display = 'none'
        }
    }

    function priorityChanged(nodeType) {
        let id = nodeType + '-priority';
        let newValue = document.getElementById(id).value
        console.log(newValue)

        let priorities = {pri1: "", pri2: "", pri3: ""}
        let nodeTypes = ['plots', 'stones', 'runes']
        let nodeTypeToSwitch = ''

        nodeTypes.forEach((x, i) => {
            let prioId = x + "-priority"
            let prioValue = document.getElementById(prioId).value
            delete priorities['pri'+prioValue];

            //if its not the current node type, but it has the same value
            if(prioId !== id && prioValue === newValue) {
                //then that is the type to switch!
                nodeTypeToSwitch = x
            }
        })

        let selectToSwitch = document.getElementById(nodeTypeToSwitch + '-priority')

        //we check which prio survived
        if("pri1" in priorities) {
            selectToSwitch.value = '1'
        } else if("pri2" in priorities) {
            selectToSwitch.value = '2'
        } else {
            selectToSwitch.value = '3'
        }
    }

    function readInput(rawQueryParams, startingValues) {
        try {
            if('hideHeader' in rawQueryParams) {
                startingValues.hideHeader = rawQueryParams.hideHeader
            }
            if ('plots' in rawQueryParams) {
                let decodedString = atob(rawQueryParams.plots);
                if (isJson) {
                    console.log("Input found")
                    let inputJson = JSON.parse(decodedString)
                    let plotsDecayList = inputJson.plots
                    let stonesDecayList = inputJson.stones
                    let runesDecayList = inputJson.runes
                    let nftGroup = createNftGroup(parseInt(inputJson.nft5), parseInt(inputJson.nft10), parseInt(inputJson.nft15))
                    console.log(nftGroup)
                    let countByDate = {}
                    let totalCount = 0;
                    plotsDecayList.forEach((x, i) => {
                        if (!(x in countByDate)) {
                            countByDate[x] = 0
                        }
                        countByDate[x]++
                        totalCount++;
                    })

                    let plotGroups = []
                    for(const dateString in countByDate) {
                        const decayDate = new Date(dateString)
                        const count = countByDate[dateString];
                        plotGroups.push(createPlotGroupFromExpiration(decayDate, count))
                    }

                    let stones = [];
                    for(const dateString of stonesDecayList) {
                        const decayDate = new Date(dateString)
                        stones.push(createStoneFromExpiration(decayDate))
                    }

                    let runes = [];
                    for(const dateString of runesDecayList) {
                        const decayDate = new Date(dateString)
                        runes.push(createRuneFromExpiration(decayDate))
                    }

                    startingValues.plots = plotGroups
                    startingValues.plotsCount = totalCount
                    templateFromInput = createPlotTemplate(plotGroups, stones, runes, nftGroup, LIVE_WALLET_TEMPLATE_NAME)
                    console.log("Input handled properly")
                }
            }
            if ('claimable' in rawQueryParams) {
                startingValues.claimable = parseFloat(rawQueryParams.claimable)
            }
        } catch (e) {
            console.log("Caught exception", e)
        }

        return startingValues;
    }


    let rawQueryParams = {
        'plots': [], //placeholders
        'plotsCount': 0,
        'claimable': 0.0
    }
    location.search.substr(1).split("&").forEach(function(item) {rawQueryParams[item.split("=")[0]] = item.split("=")[1]})

    let defaultPlotsCount = 1;
    let defaultPlots = [createPlotGroupFromCreation(new Date(), defaultPlotsCount)];
    let defaultClaimable = 0;
    let startingValues = {
        plots: defaultPlots,
        claimable: defaultClaimable,
        plotsCount: defaultPlotsCount,
        'hideHeader': 'no'
    }

    startingValues = readInput(rawQueryParams, startingValues);
    document.getElementById("scalc_num_of_plots").value = startingValues.plotsCount;
    document.getElementById("scalc_num_of_claimable").value = startingValues.claimable;

    document.getElementById("calculator_num_of_claimable").value = startingValues.claimable;

    if(GLOBAL_DATA.inputs.duration_in_future === null) {
        GLOBAL_DATA.inputs.duration_in_future = 0;
    }
    if(GLOBAL_DATA.inputs.wallets_hardcap === null) {
        GLOBAL_DATA.inputs.wallets_hardcap = 1;
    }
    if(GLOBAL_DATA.inputs.invested === null) {
        GLOBAL_DATA.inputs.invested = 0;
    }
    if(GLOBAL_DATA.inputs.cashed_out_already === null) {
        GLOBAL_DATA.inputs.cashed_out_already = 0;
    }
    setInitialInputs(GLOBAL_DATA.inputs)
    setInitialZnftInputs(GLOBAL_DATA.znft_inputs)
    //document.getElementById("znft_avg_bot_profit").innerHTML = (ZNFT_AVERAGE_MONTHLY_BOT_ROI * 100) + "%";

    runSimpleCalculation();
    syncAllTemplates();
    if(userHasTemplates()) {
        runCalculation()
    }

    openTab('znft-tab')
    if (startingValues.hideHeader === 'yes') {
        document.getElementById('horde-header').style.display = 'none'
    }
    document.getElementById('main-container').style.display = 'block'
    console.log(GLOBAL_DATA);

    runZnftCalculation()
</script>
